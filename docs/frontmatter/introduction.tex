\chapter{Introduction}
\label{chap:introduction}

\section*{Problem Statement} % (fold)
\label{sec:Problem Statement}
JavaScript already includes some concepts known from functional programming.
For example, it supports higher-order functions or auto-currying of function
parameters.\\
However, JavaScript lacks many concepts included in pure functional languages
such as Haskell. Based on the previously mentioned language features, it is
possible to recreate some features of Haskell. Its standard library, for
example, has a wide range of operations to transform or evaluate lists.
JavaScript, on the other hand, only implements a few of these operations for
its arrays. In addition, Haskell only executes these operations if the list or
parts are consumed (lazy evaluation). Thus, it invests no unnecessary computing
time.\\
The JavaScript iteration protocols~\cite{mdn_protocols} allow implementing this laziness. This
project work, therefore, explores building a functional standard library based
on these iteration protocols, providing operations analogous to the Haskell
standard library.

However, the goal is not only to examine operations on lists but also how it is
possible to implement Haskell type classes in JavaScript. The type class monad,
for example, makes it possible to write more abstract functions that can handle
a wide variety of data structures. 

The resulting artifacts integrate seamlessly into the Web UI toolkit
"Kolibri"~\cite{kolibri}. On the one hand, this integration means that the
artifacts belong to the toolkit. On the other hand, they maintain the high
standards of the Kolibri. These standards include high code quality, expressed
by automated tests, fully typed JavaScript using JSDoc, and keeping the
Kolibri's zero dependency approach. For this, things like specific data
structures or the integrated testing framework, which Kolibri already brings,
can be used.

% section Problem Statement (end)
\section*{Results} % (fold)
\label{sec:Introduction_Results}

Through the knowledge gained, a functional standard library has emerged, which
mainly consists of two parts:\\
\begin{enumerate}
  \item \textbf{Sequence library:} The Sequence library introduces a new data structure
called "sequence". A sequence implements the JS iteration protocols and can
therefore be lazily evaluated. In addition, the Sequence library provides
various operations on a sequence to transform and evaluate it. These operations
work on sequences and any data structure that implements the iteration
protocols! Thus, among other things, JavaScript arrays can also be lazily
evaluated and transformed using the Sequence library.
\item \textbf{Monadic API in JavaScript:} The knowledge gained from the Sequence
  library enabled adapting the type class Monad from Haskell into JavaScript.
  This type class is defined as JSDoc, which allows writing generic functions
  that can handle data structures of various kinds. For a data type to be
  compatible with such a function, it must implement each operation defined by
  the JSDoc type |MonadType|. \\ 
  The sequence already implements this type completely. Since the Sequence
  library allows converting any iterable into a sequence, these operations are
  available for all iterable objects! To show the versatility of the
  |MonadType|, an implementation for the already existing type |MaybeType| was
  also added. The definition of the monad in JavaScript allows the
  implementation of language-integrated queries (LINQ). LINQ allows querying
  different data structures implementing the monadic API using the exact same
  notation. \\ 
  The power of this concept becomes even more visible in practical examples: A
  new type |JsonMonad|, which also implements the monadic API, allows the
  processing of inconsistent JSON files using language-integrated queries and
  thus prevents frequently occurring mistakes. This makes it easier to process
  data that originates from an API, for example.
\end{enumerate}

\subsection*{Examples} % (fold)
\label{sub:introduction_Examples}
The lazy evaluation of the sequence library offers the possibility to implement
the alpha-beta heuristic~\cite[Ch. 5]{hughes_why_1989}. 
This algorithm allows the implementation of a computer-controlled opponent for
turn-based games. We have implemented such an opponent for the game Tic tac toe
to demonstrate the Sequence library. This opponent automatically selects the
best move. Figure~\ref{img:intro_ttt_playfield} shows a screenshot of a web
application that uses this algorithm:
\begin{figure}[H]
    \centering
    \includegraphics[width=0.4\textwidth]{./mainmatter/pictures/tic-tac-toe-field.jpg}
    \caption{A website using the algorithm}
    \label{img:intro_ttt_playfield}
\end{figure}
% subsection Examples (end)

\subsection*{Testing} % (fold)
\label{sub:intro_Testing}

Automated unit tests ensure the correctness of the two previously explained
artifacts. Since many operations of the Sequence library must ensure the same
properties, testing in a structured way is necessary. A  so-called testing
table represents this structure. This testing table allows writing general
tests which assert specific properties which apply to every operation. Newly
discovered bugs that can potentially occur in all of these operations can thus
be caught in a single place by one single test.\\
In addition, some operations must fulfill unique properties or invariants. When
an operation is performed on a sequence, these invariants must always hold,
regardless of the underlying sequence. The testing table, therefore, also
supports the definition of such invariants as predicates. This allows finding
bugs occurring in edge cases, such as the empty sequence.
% subsection Testing (end)

% section Results (end)


\section*{Methodology} % (fold)
\label{sec:Methodology}

% section Methodology (end)

\section*{Reader Guidance} % (fold)
\label{sec:Reader Guidance}

% section Reader Guidance (end)
