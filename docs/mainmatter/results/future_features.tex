\section{Future Features}
\label{sec:Future Features}
This chapter covers unimplemented functions. These include implementations that
were no longer possible during the work or resulted from user testing feedback.
The following articles describe the most relevant features and explain why it
makes sense to implement them at a future point in time.

\subsection{Logging}
\label{sub:Logging}
Logging is a topic that has come up several times. It appears, on one hand,
during the implementation of the Sequence Library, but also through as feedback
from a test proband. In our computer science project work from the fifth
semester IP5 we had to implement a logging framework. This would also be useful
to include in the Sequence Library. Especially in case of errors, analyzing
messages from the involved functions would be helpful. Currently, the logging
framework is only included in a part of the test framework. But this could be
extended in a next step.

\subsection{Operators and Operations}
\label{sub:Operators and Operations}

\subsubsection{uncons}
\label{subsub:uncons}
|uncons| is an operation that returns the first and the rest of an iterable in a
pair. Basically, this operation is already included in the sequence library.
But only as an un-safe variant. That means, |uncons| applied to an empty list
fails. Thus one would have a version, which for example, wraps the result in a
|MaybeType|. |uncons| on an empty list would then return |Nothing|. The
api documentation page~\cite{hoogle_uncons} describes the function in detail.

\subsubsection{tail}
\label{subsub:tail}
|tail| ~\cite{hoogle_tail} is a useful function that removes the first element of an |Iterable|
and returns the rest of it. By implementing tail, one have to pay attention to
empty |Iterable| single element case. An option could be to return a
|MaybeType|. |Nothing|, if the list has one or zero elements, and
|Just| including the result otherwise.

\subsubsection{unfoldr}
\label{subsub:unfoldr}
|unfoldr| is a powerful concept of creating sequences of data. It would
supplement the options to make new |Iterable| beside the |Sequence|
constructor. It works on a |MaybeType|. |unfoldr| creates an |Iterable| which returns
a |PairType| wrapped in Just with the value of the current iteration and the next
element. If the stop condition is fulfilled, |unfoldr| return |Nothing|. For
further information, have a look at the documentation on hoogle~\cite{hoogle_unfoldr}.

\subsubsection{iterate}
\label{subsub:iterate}
|iterate| takes two arguments. The first argument is a function, and the second
is a start value. It generates an infinite |Iterable| of repeated applications of
the function to the calculated value. You will find more information about
|iterate| on hoogle~\cite{hoogle_iterate}.

\subsection{JINQ Functions}
\label{sub:JINQ Functions}
It is possible to get errors when working with JINQ and JSON Monad by grabbing
not present values. That means if a function in select accesses a property
which is not defined, it will throw an error. This kind of null-case handling
takes a lot of work. To remedy this situation, having error-safe functions like
|safeSelect| to access probably present values would be excellent.

\subsection{Applications}
\label{sub:Applications}
\subsubsection{Fixpoint Sequence}
\label{subsub:Fixpoint Sequence}
In the mathematical context, having a tool for approximations is helpful. A
constructor for such a case could be the Fixpoint Sequence. It allows us to
find an approximation with a given number of iterations or by providing a value
of minimal deviation.

\subsubsection{A Kind of Scalpel}
\label{subsub:A Kind of Scalpel}
Scalpel~\cite{scalpel} is a Haskell library to scrap web content. Building a similar
application based on the present implementations could be possible. With JINQ
and |JsonMonad|, we already have a scraping tool for JSON Objects. A future
implementation could use a similar approach to develop such an application.
