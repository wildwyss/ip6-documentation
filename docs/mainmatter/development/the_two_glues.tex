\section{Gluing Programs together}
John Hughes says functional programming languages provide two extra ways to
better partition programs and easily hang them together later. He refers to
this as "glue". These "glues" are on the one hand higher order functions and on
the other hand lazy evaluation. \cite{hughes_why_1989}

\subsection{Using these Glues in Haskell} % (fold)
\label{sub:Using these Glues in Haskel}

\subsubsection{Higher Order Functions in Haskell} % (fold)
\label{sec:Higher order functions Haskell}
Higher order functions are functions that receive another function as arguments
or produce a function as a result. In Haskell, where the whole program is
actually a single function, this concept is of course particularly strong.
The easiest way to understand higher order functions is to look at an
example:

\begin{lstlisting}[style=Haskell, caption=Higher order functions in
Haskell \label{lst:hof_haskell}]
double    = \x -> 2 * x
quadruple = \x -> 4 * x
doubles   = map double [1,2,3,4]
quads     = map quadruple [1,2,3,4]

print $ doubles ++ quads
-- Prints '[2,4,6,8,4,8,12,16]'
\end{lstlisting}

Listing~\ref{lst:hof_haskell} shows how higher order functions work in Haskell.
Code can easily be reused this way, since |map| can be parametrized with a
function.
% subsubsection Higher order functions Haskell (end)

\subsubsection{Lazy evaluation} % (fold)
\label{subsub:Evaluation}
Lazy evaluation means that only as many program statements are evaluated as are
actually required. This makes it possible to work with lists that have an
infinite amount of values. This can best be shown in an example as well.

\begin{lstlisting}[
  style=Haskell,
  caption=lazy evaluation in Haskell,
  label={lst:lazy_eval_haskell}
]
as = [1..]*'\label{line:lazy_eval_haskell_1}'*
doubles = double as*'\label{line:lazy_eval_haskell_2}'*

print $ take 4 doubles 
-- Prints '[2,4,6,8]'
\end{lstlisting}

Line~\ref{line:lazy_eval_haskell_1} in listing~\ref{lst:lazy_eval_haskell}
defines a list with infinite values is created. Then the function |double|
defined in Listing~\ref{lst:hof_haskell}, is applied on this list. Since the
list has an infinite amount of elements this would take forever. But since
Haskell evaluates its statements lazy, Nothing happens on
line~\ref{line:lazy_eval_haskell_2}. The |double| function is only applied when
the elements are actually used. This is only the case when they are printed
with |print|. With |take| the list is reduced to four elements. The function
|double| is then only applied to these four elements. \\ More theoretically,
when the function |f| is applied to |g x|, |g| produces only as much output as
|f| actually needs. Therefore, working with a big amount data becomes much more
convenient and faster as well. If the elements in a list are generated with a
rule (as with list comprehensions), lazy evaluation brings great advantages:
The whole list will never materialize in the memory, but only the current
value. So you don't have to worry about what happens when large amounts of data
are processed. \\ Using these two concepts, it is much easier to build large
programs consisting of small parts.
% subsubsection Lazy evaluation (end)
% subsection Using the glues in Haskell (end)

\subsection{Using these Glues in JavaScript} % (fold)
\label{sub:Using these Glues in JavaScript}

\subsubsection{Higher Order Functions in JavaScript} % (fold)
\label{subsub:Higher Order Functions in JavaScript}
Higher order functions in JavaScript work similarly as they to in Haskell. \\
So the meaning of the listing~\ref{lst:hof_haskell} can be translated to 
JavaScript like:

\begin{lstlisting}[
  style=ES6,
  caption=Higher order functions in JavaScript,
  label={lst:hof_in_js}
]
const double    = x => 2 * x;
const quadruple = x => 4 * x;
const doubles   = [1,2,3,4].map(double);
const quads     = [1,2,3,4].map(quadruple);

console.log(doubles.concat(quads));
// => Logs '2, 4, 6, 8, 4, 8, 12, 16'
\end{lstlisting}

% subsubsection Higher Order Functions in JavaScript (end)

\subsubsection{Lazy Evaluation in JavaScript} % (fold)
\label{subsub:Lazy Evaluation in JavaScript}

% subsubsection Lazy Evaluation in JavaScript (end)
When it comes to lazy evaluation in JavaScript, it becomes less intuitive:
JavaScript does not know this concept when working with its in-built arrays.
Mapping over an array producing a side effect can shed some light on this:

\begin{lstlisting}[
  style=ES6,
  caption=JavaScript evaluates eagerly,
  label={lst:js_eagerly_eval}
]
const as     = [1,2,3,4,5];
const bs     = [];
const mapped = as.map(x => {
  bs.push(x);
  return 2*x
});

console.log(mapped.slice(0,4));
// => Logs '2, 4, 6, 8'
console.log(bs);
// => Logs '2, 4, 6, 8, 10'
\end{lstlisting}

Through listing~\ref{lst:js_eagerly_eval} it becomes clear, that although only
the first four elements of the array are actually used, each element of the
array is still traversed using the |map| function. This can be seen from the
fact that the array |bs| contains all elements of the array |as| and not just
the first four.
\paragraph{Lazy Evaluate Iterables} % (fold)
This is a big limitation when working with JavaScript. Fortunately, JavaScript
provides a way to emulate this laziness using the Iterable protocols, which are
described in section~\ref{sec:TODO}.
% subsubsection Lazy Evaluation in JavaScript (end)


