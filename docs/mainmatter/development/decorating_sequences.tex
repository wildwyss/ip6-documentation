\section{Decorating Sequences}
\label{sec:Decorating Sequences}
This chapter explores how to process Sequences by implementing the Decorator 
Pattern and effectively managing Sequence state. And then we will discover 
powerful techniques to enhance Sequence functionality and manipulate data.

\subsection{Decorator Pattern}
\label{sub:Decorator Pattern}
Let us look at the Decorator Pattern~\cite[p.~226]{gang_of_four_depa} to understand the content of the 
following sections. In object-oriented programming, the Decorator Pattern is a 
widely used concept. An object decorates another, as the name implies. As a 
result, an outer object refers to an inner object, and both implement the same 
interface. Therefore, the outer object forwards requests to the inner one. It 
modifies the calls on demand to manipulate or decorate the functionality of the 
inner one. Figure \ref{fig:seq_diagramm} shows how a decorator forwards the receiving calls and 
transfers the answer back to the client.

% TODO: replace
\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{./mainmatter/pictures/decorator_sequence_diagramm.png}
    \caption{Decorator Patter Sequence Diagram}
    \label{fig:seq_diagramm}
\end{figure}

The Decorator Pattern is often used in object-oriented programming languages 
because it adds additional functionality to an object at runtime. It is also 
possible to add extended functionality to a single class object. In the 
following, we will see how to exploit this to manipulate and change an Iterable.

\subsection{Processing Sequences}
\label{sec:Processing Sequences}
We use precisely that decorating approach to process Iterables further. 
The goal is to find a way to manipulate sequences so that they can solve 
complex problems. With many other programming languages, it is possible to write 
programs this way. Lists and operations on lists solve numerous problems in 
computer science. This way of programming has the advantage that the structure 
of the code is declarative. This code is more straightforward to understand 
and easier to extend.

\subsubsection{Processing Iteratbles with Functions}
\label{subsub:Processing Iteratbles with Functions}
In the following, |map| serves as a representative for any function of the
Sequence library. We call these functions in the following operators.
According to the package they are in.
Listing~\ref{lst:impl_map} shows how |map| processes a 
Sequence. For this, we use the Decorator approach just mentioned. To keep the 
example simple, on line~\ref{line:seq_definition}, a client calls the |map| 
operator with a Sequence of numbers. However, it could process any iterable.
\newline
On line~\ref{line:args}, the function signature shows that a client can invoke 
|map| with two arguments: a mapper-function capable of processing an element of 
an iterable and an iterable. An iterable must adhere to the JS iterator protocol 
outlined in Section~\ref{subsub:The Iterable Protocol}. As a result, |map| can 
process Sequences, Arrays, or any other iterable. 

\begin{lstlisting}[
  style=ES6, 
  caption=Implementation of map,
  label={lst:impl_map}
  ]
const map = mapper => iterable => { *'\label{line:args}'*
*'\label{line:state_iterable}'*
const mapIterator = () => {
   const inner = iteratorOf(iterable);*'\label{line:state_iterator}'*
   let mappedValue;
 
   const next = () => {
     const { done, value } = inner.next();*'\label{line:inner_next}'*
     if (!done) mappedValue = mapper(value);
 
     return { /**@type boolean */ done, value: mappedValue }
   };
 
   return { next };
  };
 
  return createMonadicSequence(mapIterator);
};

const sequence = Sequence(0, x => x < 10, x => x++);*'\label{line:seq_definition}'*
const mapped   = map(x => x * 2)(sequence);*'\label{line:obj_mapped}'*
\end{lstlisting}

Because |map| decorates iterables, |map| also returns an object of type |Iterable<T>|. 
We define this object on line~\ref{line:obj_mapped} as |mapped|. 
Consequently, |map| also has a next function. Since the Iterable protocol 
specifies only this single function, it is the only one that must be externally 
callable. The object |mapped| now forwards function calls on |next| to the
inner function |next|, on line~\ref{line:inner_next}. The |mapper| function then 
processes the result and returns it. This process involves decorating the next function of the inner iterable.

\subsection{Benefits form the Decorater Approach}
\label{sub:Benefits form the Decorater Approach}
This section discusses the benefits and consequences of using the Decorator 
Pattern to implement the Sequence library. We start with the fact that functions 
stand-alone, then discuss the options for managing State.

\subsubsection{Stand-alone Functions}
\label{subsub:Standalone Functions}
In an object-oriented approach, the Sequence object would provide access to the 
operations. Therefore, such operators are available by using dot notation,
similar to Java implements the Stream API \cite{java_stream}. 
However, with the approach of programming the operators independently, there 
are three significant advantages:

\begin{enumerate}
  \item {Strict adherence to the open-close principle. Changes to an operator do
      not affect the implementation of Sequence. Also, extensions to the 
      Sequence library do not affect existing code.
    }
  \item{Adherence to the single responsibility approach. The Sequence 
      constructor has only the task of creating a sequence. Mapping the
    elements of a sequence is not its responsibility.
  }
  \item{Easy scalability is guaranteed. It is very straightforward to add new 
    functionality from the outside.
  }
\end{enumerate}

Since the independent implementation of the iterable operators, the last
argument is the iterable object. The operator defines the 
parameters in a curried style. So it is possible to benefit from eta-reduction 
in different situations.

\subsubsection{Stateful Decorating}
\label{subsub:Stateful Decorating}
A state is present as soon as operators decorate iterables or implement 
additional functionalities. This chapter explores the implementation of state
within operators and the implications it involves.

There are two valid possibilities for including the state.
The first scenario places the state into the closure scope to the surrounding 
operator of the iterator. The second scenario implements the state into the 
closure scope of the iterator. In both variants, it is crucial to ensure that 
the underlying object remains unchanged.

\subsubsection{Scenario 1}
Listing~\ref{lst:scen_1} shows an example of a Sequence generating numbers from
zero to five. On line ~\ref{line:scen_1_state}, value |i| works as a counter 
and represents the state. 
A call to |SampleIterator| creates a state which is valid for the entire 
object's lifetime.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 1 - State in closure scope of iterable,
  label={lst:scen_1}
  ]
const SampleIterable = () => {

  let i = 0; *'\label{line:scen_1_state}'*
  const next = () => {
    return { done: i > 5, value: i++ };
  };

  const copy = ...

  return {[Symbol.iterator]: () => ({ next })}
};
\end{lstlisting}

Listing~\ref{lst:scen_1_demo} shows a possible program flow. 
The program first creates an object of |SampleIterator|, maps it and processes
an element on the original object. Note, that on line~\ref{line:scen1_map} |map| also 
uses the same object. Line~\ref{line:scen1_output} shows an expected result. 
To achieve this result, copying the object before processing is necessary.
That implies that each sequence must be copyable. Generating a new 
Sequence with the same parameters allows for creating a copy of it. 
The same is true for any function that decorates an iterable.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 1 - Example usage,
  label={lst:scen_1_demo}
  ]
const seq = SampleIterable(0, x => x < 5, x => x++); // [0, 1, 2, 3, 4]
const mapped = map(id)(seq); *'\label{line:scen1_map}'*

for (const elem of mapped) {
  break; // Just consuming one element
}
for (const elem of seq) {
  console.log(elem);
}
// => Logs: '[0, 1, 2, 3, 4]' *'\label{line:scen1_output}'*
\end{lstlisting}

In many respects, copying is an elaborate thing. All operators and constructors 
dealing with sequences must implement it. Thus, implementation errors are 
almost certain. On the other hand, it is an extra effort from a performance point 
of view. It means more function calls and also larger stack calls to manage.
The advantage of this implementation is that partially processed iterators can
be further utilized while maintaining their current state, without
reinitializing the state with a new iteration.
Because all objects must have copy implemented, operators can 
only process objects that implement copy. That means JavaScipt Arrays or HTML 
Collection are not be processable.

\subsubsection{Scenario 2}
Listing~\ref{lst:scen_2} represents scenario 2. Here, the state is on 
line~\ref{line:scen_2_state}. Running the code from the previously
example~\ref{lst:scen_1_demo} produces the same output. The distinction lies in
the fact that the object does not need to be copyable. Each call to |[Symbol.iterator]| 
creates a new object. This type of iterator is immutable. Another advantage is
that all operators within the Sequence library can handle objects that have the
|[Symbol.iterator]| property, including JavaScript Arrays.
\newline
As is now apparent, there is a reason for the deep nesting of objects, according 
to chapter~\ref{sub:Types of Iterables}. The JS iteration protocols design the 
interface in this way to achieve this level of immutability, and iterable 
objects behave as expected.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 2 - State in closure scope of iterator,
  label={lst:scen_2}
  ]
const SampleIterable2 = () => {

  return {
    [Symbol.iterator]: () => {
      let i = 0; *'\label{line:scen_2_state}'*
      return {
        next: () => ({ done: i > 5, value: i++ })
      }
    }
  };
};
\end{lstlisting}

In this chapter, we have examined the possibilities for adding state to 
Sequences. Due to the advantages of immutability, we built the Sequence library 
according to Scenario 2 with an immutable approach.


\subsection{Adding Monadic Functions to Iterables}
\label{sub:Adding Monadic Functions to Iterables}
In this last section of this chapter, we will highlight one more function we 
have left out so far. It is about the function |createMonadicSequence|, which has
already appeared in a previous Listing.

\subsubsection{A Convenience Function}
\label{subsub:A Convenience Function}
In Section~\ref{subsub:Processing Iteratbles with Functions} Listing~\ref{lst:impl_map} shows the implementation of |map|. This needs a function
|mapIterator|, which surrounds the function |next|. |createMonadicSequence| now 
expects such an iterator. As the name suggests, |mapIterator| is part of the 
iterable object that follows the JS Iterator protocol.
Listing~\ref{lst:createMonadicSequence} demonstrates the implementation of 
|createMonadicSequence|.

\begin{lstlisting}[
  style=ES6, 
  caption=Implementation of createMonadicSequence,
  label={lst:createMonadicSequence}
  ]
/**
 * Builds an {@link SequenceType} from a given {@link Iterator}.
 * @template _T_
 * @param { () => Iterator<_T_> } iterator
 * @returns { SequenceType<_T_> }
 */
 const createMonadicSequence = iterator => {
   *'\label{line:start_createMonadicSequence}'* const result = {[Symbol.iterator]: iterator};
  return setPrototype(result);
};*'\label{line:end_createMonadicSequence}'*


/**
 *
 * @template _T_
 * @param { Iterable<_T_> } iterable
 * @returns { SequenceType<_T_> }
 */
 const setPrototype = iterable => { *'\label{line:setPrototype}'*
  Object.setPrototypeOf(iterable, SequencePrototype);
  return /**@type SequenceType*/ iterable;
};
\end{lstlisting}

Between line~\ref{line:start_createMonadicSequence} and 
line~\ref{line:end_createMonadicSequence}, we can recognize two main tasks of the
function |toMonadicSequence|.

\begin{itemize}
  \item{Assign the passed iterator to the |[Symbol.iterator]| property}
  \item{Add the Sequence prototype to the resulting object}
\end{itemize}

Many of the operations of the Sequence library use this code.
Outsourcing the code helps to improve the code base's overview and readability.
The following section explains what the prototype is all about.

\subsubsection{Sequence Prototype}
\label{Sequence Prototype}
An object in JavaScript has one or more prototypes. Prototypes define functions
that are available to the corresponding object. The |createMonadicIterable|
function expects the passed argument to be of type |Iteratble<T>|. The subsequent
function |setPrototype| on line~\ref{line:setPrototype} sets the Sequence 
prototype to this iterable. This causes some functions to be available on each 
|SequenceType|. These are, among others, monadic functions. You will read more
about Monads and there functionality in chapter~\ref{sec:Monads in JavaScript}. 
|SequenceType| represents a Sequence and the monadic functions defined on it. 
Listing~\ref{lst:sequence_type} shows the definition of the type.

\begin{lstlisting}[
  style=ES6, 
  caption=SequenceType definition,
  label={lst:sequence_type}
  ]
/**
 * @typedef {
 *   {
 *     and:  <_U_>(bindFn: (_T_)    => SequenceType<_U_>) => SequenceType<_U_>,
 *     pure: <_U_>(_U_)             => SequenceType<_U_>,
 *     fmap: <_U_>(f: (_T_) => _U_) => SequenceType<_U_>,
 *     empty: ()                    => SequenceType<_T_>
 *   } & Iterable<_T_>
 * } SequenceType
 */
\end{lstlisting}

Why is this necessary? With this approach, we can ensure that Sequences become
monadic but still iterable. Monadic APIs can thus also process Sequences. An
example of this is JINQ. Chapter~\ref{TODO} discusses JINQ in detail. 
\newline
The most excellent solution to this problem will be if |SequenceType| combines
two types. To some extent, this is possible with the union
Type~\cite{js_doc_types} of
JavaScript. This defines that an object is of one type or the other. However, it
cannot be both at the same time. |SequenceType| is therefore defined to be a
mixture of type and prototype.
