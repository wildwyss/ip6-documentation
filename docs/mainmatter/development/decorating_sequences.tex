\section{Decorating Sequences}
\label{sec:Decorating Sequences}
This section explores how to modify sequences by implementing the decorator 
pattern and effectively managing sequence state.

\subsection{Decorator Pattern}
\label{sub:Decorator Pattern}
Let us look at the decorator pattern~\cite[p.~226]{gang_of_four_depa} to understand the content of the 
following sections. In object-oriented programming, the decorator pattern is a 
widely used concept: An object decorates another, as the name implies. As a 
result, an outer object holds an inner object, while both implement the same 
interface. The outer object forwards requests to the inner one. This enables
the outer to modify (decorate) the behavior of the inner. 
Figure \ref{fig:seq_decorator} shows how a decorator forwards the receiving calls and 
transfers the answer back to the client.

\begin{figure}[H]
  \centering
  \begin{sequencediagram}                                                      
    \newthread{client}{:Client}                                                        
    \newinst[3]{decorator}{:Decorator}                                                     
    \newinst[3]{decorated}{:Decorated}                                                     

    \begin{call}{client}{operation()}{decorator}{return value}                                  

      \begin{sdblock}{}{optionally do somthing befor calling
        inner.operation()}
        \begin{call}{decorator}{}{decorator}{}                                  
        \end{call}                                                                    
      \end{sdblock}

      \begin{call}{decorator}{operation()}{decorated}{}                                  
      \end{call}                                                                    

      \begin{sdblock}{}{optionally do somthing after calling
        inner.operation()}
        \begin{call}{decorator}{}{decorator}{}                                  
        \end{call}                                                                    
      \end{sdblock}

    \end{call}                                                                    
  \end{sequencediagram}    
  \caption{Decorator Sequence Diagram}
  \label{fig:seq_decorator}
\end{figure}

The decorator pattern is often used in object-oriented programming languages 
because of its ability to add functionality to an object at runtime. It is also 
possible to add extended functionality to a single class object. This pattern
gives a great way to modify the behavior of iterables! The Sequence library
uses this approach to create operations to transform sequences.

\subsection{Processing Sequences}
\label{sub:Processing Sequences}

\subsubsection{Processing Iterables with Functions}
\label{subsub:Processing Iterables with Functions}
In the following, |map| serves as a representative for any function of the
Sequence library. We call such functions operators, according
to the package they are in.
Listing~\ref{lst:impl_map} shows how |map| processes a sequence. The
implementation uses the decorator approach just mentioned. |map| decorates a
sequence on line~\ref{line:obj_mapped}.
\newline
The function signature of |map| on line~\ref{line:args} shows that a client
can invoke |map| with two arguments:

\begin{enumerate}
  \item{A mapper-function capable of transforming an element of any |Iterable|}
  \item{An object of type |Iterable<T>|}
\end{enumerate}

An iterable must adhere to the JS iteration protocols outlined in
section~\ref{subsub:The Iterable Protocol}. Therefore, |map| can process
sequences, arrays, or any other iterable. 

\begin{lstlisting}[
  style=ES6, 
  caption=Implementation of map,
  label={lst:impl_map}
  ]
const map = mapper => iterable => { *'\label{line:args}'*
*'\label{line:state_iterable}'*
const mapIterator = () => {
   const inner = iteratorOf(iterable);*'\label{line:state_iterator}'*
   let mappedValue;
 
   const next = () => {
     const { done, value } = inner.next();*'\label{line:inner_next}'*
     if (!done) mappedValue = mapper(value);
 
     return { done, value: mappedValue }
   };
 
   return { next };
  };

  *'// explained in \ref{sub:Adding Monadic Functions to Iterables}'*
  return createMonadicSequence(mapIterator); };

const sequence = Sequence(0, x => x < 10, x => x + 1);*'\label{line:seq_definition}'*
const mapped   = map(x => x * 2)(sequence);*'\label{line:obj_mapped}'*
\end{lstlisting}

Because |map| decorates iterables, it also returns an object adhering to JS
iteration protocols. We define this object on line~\ref{line:obj_mapped} as
|mapped|. Consequently, |map| also has a function called |next|. Since the JS
iteration protocols specify only this single function, it is the only one that
must be exposed. The object newly created object |mapped| forwards function
calls on |next| to the inner function |next|, on line~\ref{line:inner_next}.
The |mapper| function then processes the result and returns it. So |map|
decorates the function |next| of the inner iterable.

\subsection{Benefits of the Decorator Approach}
\label{sub:Benefits of the Decorator Approach}
\subsubsection{Stand-alone Functions}
\label{subsub:Standalone Functions}
In an object-oriented approach, the sequence object would provide a function
|map|. Therefore, such operators are available by using the dot notation,
similar to Java implements the Stream API \cite{java_stream}. 
However, with the approach of providing independent functions, there 
are three significant advantages:

\begin{enumerate}
  \item {Adherence to the open-close
      principle~\cite[p.~3]{eilebrecht_patterns_2019}. Changes to an operator
      do not affect the implementation of constructors which create sequences. Also,
      extensions to the Sequence library do not affect existing code.
    }
  \item{Adherence to the single responsibility approach. The constructor
    |Sequence| has only the task of creating a sequence. Mapping the elements
  of a sequence is not its responsibility. }
  \item{Easy scalability is guaranteed. It is very straightforward to add new
    functionality from the outside. }
\end{enumerate}

Additionally, the |operators| implement their arguments in a curried-style,
passing the receiver at the last position allows the use of eta-reduction in
many situations. More about this in section~\ref{subsub:Placing the Receiver at
the End}.

\subsubsection{Stateful Decorating}
\label{subsub:Stateful Decorating}
A state is present as soon as operators decorate iterables or implement 
additional functionalities. 

There are two valid possibilities for including state:
\begin{enumerate}
  \item Placing the state into the closure scope of the iterable.
  \item Implementing the state into the closure scope of the iterator.
\end{enumerate}
In both variants, it is crucial to ensure that the underlying object remains
unchanged.

\subsubsection{Scenario 1: Placing the State inside the Iterable}
\label{subsub:Scenario 1}
Listing~\ref{lst:scen_1} shows an example of a sequence generating numbers from
zero to five. On line ~\ref{line:scen_1_state}, value |i| works as a counter 
and represents the state. 
A call to |SampleIterator| creates a state which is valid for the entire 
iterbale's lifetime.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 1 - State in closure scope of iterable,
  label={lst:scen_1}
  ]
const SampleIterable = () => {

  let i = 0; *'\label{line:scen_1_state}'*
  const next = () => {
    return { done: i > 5, value: i++ };
  };

  return { [Symbol.iterator]: () => ({ next }) }
};
\end{lstlisting}

Listing~\ref{lst:scen_1_demo} shows a possible program flow. The program first
creates an object of |SampleIterable|, maps it and processes an element on the
original object. Note, that on line~\ref{line:scen1_map} |map| also uses the
same |Iterable|. Line~\ref{line:scen1_output} shows an expected result.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 1 - Example usage,
  label={lst:scen_1_demo}
  ]
const seq = SampleIterable(); // [0, 1, 2, 3, 4]
const mapped = map(id)(seq); *'\label{line:scen1_map}'*

for (const elem of mapped) {
  console.log(elem);
  break; // Just consuming one element
}
// => Logs: '0'

for (const elem of seq) {
  console.log(elem);
}
// => Should log: '0, 1, 2, 3, 4' *'\label{line:scen1_output}'*
\end{lstlisting}
However, since both loops operate on the same iterable (|seq|), the second output
will not give the expected result but "1, 2, 3, 4".\\
To achieve the expected result, |map| must copy the object before processing.
That implies that each iterable must be copyable. An example implementation
of a copyable iterable shows listing~\ref{lst:iterable_with_copy}.

\begin{lstlisting}[
  style=ES6, 
  caption=Iterable with copy,
  label={lst:iterable_with_copy}
  ]
const SampleIterable = () => {

  let i = 0;
  const next = () => {
    return { done: i > 5, value: i++ };
  };

  *'\colorbox{code-highlight}{const copy = () => SampleIterable();}'*

  return {
    [Symbol.iterator]: () => ({ next }),
    copy: copy *'\label{line:iterable_copy}'*
  }
};
\end{lstlisting}
Since |copy| must be callable from outside, returning it alongside 
|[Symbol.iterator]| on line~\ref{line:iterable_copy} is required. |map| is now
able to copy the underlying  iterable before consuming its elements.
However, |map| itself must also implement |copy|, because its interface must be
the same as the decorated object (and also to ensure that iterables created
using |map| can be decorated as well). The following listing~\ref{lst:map_with_copy} 
shows an implementation of |map| supporting copy:

\begin{lstlisting}[
  style=ES6, 
  caption=Implementation of map with copy,
  label={lst:map_with_copy}
  ]
const map = mapper => iterator => {
 const inner = iterator.copy();*'\label{line:copy_of_inner}'*
 let mappedValue;

 const next = () => {
   const { done, value } = inner[Symbol.iterator]().next();*'\label{line:consuming_inner}'*
   if (!done) mappedValue = mapper(value);
   return { done, value: mappedValue }
 };

 return {
   [Symbol.iterator]: () => ({ next }),
   copy: () => map(mapper)(inner)*'\label{line:return_copy_map}'* };
};
\end{lstlisting}
On line~\ref{line:copy_of_inner}, |map| references a copy of the original
iterable. Further processing on line~\ref{line:consuming_inner} works on this 
copy to protect the original from being mutated.

In many respects, |copy| is an elaborate thing. All operators and constructors 
dealing with iterables must implement it. Thus, implementation errors are 
almost certain. On the other hand, it is an extra effort from a performance point 
of view. It means more function calls and also larger call stacks to manage.
The advantage of this implementation is that partially processed iterators can
be further utilized while maintaining their current state, without
reinitializing the state with a new iteration.
Operators can only process objects that implement |copy|. That means other
iterable objects like arrays or |HTMLCollection| are not processable anymore,
which is a significant drawback.

\subsubsection{Scenario 2: Placing the State inside the Iterator}
\label{subsub:Scenario 2}
Listing~\ref{lst:scen_2} represents scenario 2. Here, the state is on
line~\ref{line:scen_2_state} inside the iterator. Running the code from the
previous example~\ref{lst:scen_1_demo} using this implementation produces the
expected output straight away. The distinction lies in the fact that the object
does not need to be copyable. Each call to |[Symbol.iterator]| creates a new
state. This type of iterable is immutable. Another advantage is that all
operators within the Sequence library can handle objects conform to JS
iteration protocols including JavaScript arrays.

\begin{lstlisting}[
  style=ES6, 
  caption=Scenario 2 - State in closure scope of iterator,
  label={lst:scen_2}
  ]
const SampleIterable = () => {

  return {
    [Symbol.iterator]: () => {
      let i = 0; *'\label{line:scen_2_state}'*
      return {
        next: () => ({ done: i > 5, value: i++ })
      }
    }
  };
};
\end{lstlisting}


\subsubsection{Comparing the Two Scenarios}
\label{subsub:Comparing the Two Scenarios}
In this section, we examined the possibilities for adding state to 
sequences.\\
As mentioned in section~\ref{sub:Types of Iterables}, there is a reason for 
the deep nesting of the iterator into the iterbale object. 
Each iterator can have its own state and is therefore immutable.
\\
In programming, immutability refers to creating objects that cannot be changed
once they are created. There are several advantages to using immutability in
code.
\\
Firstly, it helps in creating more reliable and bug-free programs. Since
immutable objects cannot be modified, there is no risk of accidental changes or
unintended side effects. This simplifies the code and makes it easier to reason
about.
\\
Secondly, immutability promotes functional programming practices. Immutable
data structures are the foundation of functional programming, allowing for more
predictable and declarative code that is easier to test.
\\
In Scenario 2, the immutable approach has a specific impact on an iterable.
When an iterable is immutable, each time we access its iterator, a new iterator
instance is returned. This means that it is not possible to process an iterable
partially or in multiple stages. To achieve this behavior, we need to implement
Scenario 1.
\\
Because of the significant benefits of immutability and, consequently, the
advantages of Scenario 2, we made the decision to implement this concept. As a
result, when a programmer uses a sequence, they can always depend on receiving
a new instance of it, guaranteeing consistency.


\subsection{Adding Monadic Functions to Iterables}
\label{sub:Adding Monadic Functions to Iterables}
In this last section of this chapter, we will highlight one more function we 
have left out so far. It is about the function |createMonadicSequence|, which
can be used to create iterables.

\subsubsection{A Convenience Function}
\label{subsub:A Convenience Function}
Consider Listing~\ref{lst:impl_map} once again showing the implementation of
|map|. This implementation uses a function |mapIterator|, which returns an
object containing a function |next|. Thus, |mapIterator| forms an |Iterator|.
|createMonadicSequence| now receives such an iterator as parameter.
Listing~\ref{lst:createMonadicSequence} demonstrates the implementation of
|createMonadicSequence|.

\begin{lstlisting}[
  style=ES6, 
  caption=Implementation of createMonadicSequence,
  label={lst:createMonadicSequence}
  ]
/**
 * Builds an {@link SequenceType} from a given {@link Iterator}.
 * @template _T_
 * @param { () => Iterator<_T_> } iterator
 * @returns { SequenceType<_T_> }
 */
 const createMonadicSequence = iterator => {
   *'\label{line:start_createMonadicSequence}'* const result = {[Symbol.iterator]: iterator};
    return setPrototype(result);
};*'\label{line:end_createMonadicSequence}'*
\end{lstlisting}

Line~\ref{line:start_createMonadicSequence}
to~\ref{line:end_createMonadicSequence} implement the responsibility of the
function |createMonadicSequence|:

\begin{itemize}
  \item{Assign the passed iterator to the |[Symbol.iterator]| property}
  \item{Add the sequence prototype to the resulting object}
\end{itemize}

Many of the operations of the Sequence library use this code.
Outsourcing the code helps to improve the code base's overview and readability.
The following section explains what the prototype is all about.

\subsubsection{Sequence Prototype}
\label{subsub:Sequence Prototype}
\textcquote{mdn_prototype_2023}{Prototypes are the mechanism by which
JavaScript objects inherit features from one another.}\\ 
Multiple objects can use the same implementation of functions simultaneously if
they have the same prototype.\\
\textit{Note}: An object can have just \textit{one} prototype. Hierarchies
emerge through chaining prototypes, meaning setting the prototype of a
prototype.

A prototype is just a function. As already mentioned in JavaScript functions
are objects as well. Therefore, you can define any properties on them. A static
function |setPrototypeOf| adds this prototype to an existing object. Thus, any
properties set on the prototype become available to that object. These
properties can access the current object directly with the keyword |this|.
Listing~\ref{lst:js_set_proto} shows how this works for any object:

\begin{lstlisting}[
  style=ES6,
  caption=Setting the prototype to an object,
  label={lst:js_set_proto}
]
// The prototype is just a function
const Prototype = () => null; 

// Add a new function to this prototype
Prototype.getName = function () { return this.name; };

// Creating an object with a name
const tobi = { name : "Tobi" };


// Setting the prototype
Object.setPrototypeOf(tobi, Prototype);

console.log(tobi.getName());
// => Logs 'Tobi' 
\end{lstlisting}


The function |setPrototype| on line~\ref{line:setPrototype} adds the sequence
prototype to an iterable using the function |setPrototypeOf|. This causes some
functions to be accessible on each SequenceType using the |.| (dot) notation. These are,
among others, monadic functions. You will read more about Monads and their
purpose in chapter~\ref{chap:Monads in JavaScript}.
\begin{lstlisting}[
  style=ES6,
  caption=Implementation of setPrototype,
  label={lst:set_prototype}
]
/**
 *
 * @template _T_
 * @param { Iterable<_T_> } iterable
 * @returns { SequenceType<_T_> }
 */
 const setPrototype = iterable => { *'\label{line:setPrototype}'*
  Object.setPrototypeOf(iterable, SequencePrototype);
  return /**@type SequenceType*/ iterable;
};
\end{lstlisting}

\subsubsection{The SequenceType} % (fold)
\label{subsub:The SequenceType}

The SequenceType represents a sequence and the monadic functions defined on it. 
Listing~\ref{lst:sequence_type} shows the definition of the type.
Furthermore, |toString|, |pipe| and equals |"=="| are also functions we decided to add to the
prototype. Having these functions on each SequenceType is convenient.

\begin{lstlisting}[
  style=ES6, 
  caption=SequenceType definition,
  label={lst:sequence_type}
  ]
/**
 * @template _T_
 * @typedef {
 * {
 *   and:  <_U_>(bindFn: (_T_)    => SequenceType<_U_>) => SequenceType<_U_>,
 *   pure: <_U_>(_U_)             => SequenceType<_U_>,
 *   fmap: <_U_>(f: (_T_) => _U_) => SequenceType<_U_>,
 *   empty:     ()                => SequenceType<_T_>,
 *   pipe: function(...transformers: SequenceOperation<*,*>): SequenceType<*>|*,
 *   toString:  ()                => String,
 *   "==":      (that:SequenceType<_T_>) => Boolean
 *  } & Iterable<_T_>
 * } SequenceType
 */
\end{lstlisting}

Why is this necessary? With this approach, we can ensure that sequences become
monadic but still iterable. Monadic APIs can thus also process sequences. An
example of this is JINQ. Chapter~\ref{sec:API_JINQ} discusses JINQ in detail.

\subsubsection{SequenceType vs. Iterable} % (fold)
\label{subsub:SequenceType vs. Iterable}
The SequenceType describes an object which is iterable and having their
prototype set to SequencePrototype. An object of type iterable is just
iterable. This means, every operation or operator receives an object of type iterable as
parameter and returns then an object of type SequenceType.


\subsubsection{Turning an Iterable into a SequenceType}
\label{subsub:Turn Iterables into SequenceType}
Sometimes the SequenceType must be set on an arbitrary iterable. For example,
if you want to use the monadic functions on a JavaScript array. To make this
possible, the Sequence library provides a |toMonadicIterable| function.
Listing~\ref{lst:casting_iterables} shows the
implementation of it. This function takes an arbitrary iterable and returns an
SequenceType mapped by |id| \footnote{The id (identity) function always
returns the value passed to it.}. 
Therefore, the returning object is then of the desired type SequenceType.

\begin{lstlisting}[
  style=ES6, 
  caption=Casting an arbitrary Iterable to SequenceType,
  label={lst:casting_iterables}
  ]
/**
 * Casts an arbitrary {@link Iterable} into the {@link SequenceType}.
 * @template _T_
 * @param { Iterable<_T_> } iterable
 * @return { SequenceType<_T_> }
 */
const toMonadicIterable = iterable => map(id)(iterable);
\end{lstlisting}
