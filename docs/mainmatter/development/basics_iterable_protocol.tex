\section{Sequence and Iterable in General}
\label{sec:Sequence and Iterable in General}
This section explains the concept of iterable and iterator objects and points
out features and characteristics of it. |Sequence| is one implementation of
an iterable and represents the core functionality of the implementations
related to the functional standard library. We call these functionalities in
the thesis Sequence library analogous to the package in the code
base~\cite{wildwyss_kolibri}. The following
discussion covers challenges and solutions for creating a robust and
user-friendly API.

\subsection{The Essence of an Iterator}
\label{sub:The Essence of an Iterator}
In Computer Science, iterators are a popular concept. An iterator provides
access to elements of a data structure. It does not matter if the iterator
accesses a data structure fully kept in memory (like arrays) or if it computes
the elements lazily when queried. In both ways, a function call on the iterator
retrieves the next value. Iterators are an essential part of this work.
Therefore, it is crucial to understand the fundamentals of this concept. The
following sections cover this topic in depth.

\subsection{Iterators in JavaScript}
\label{sub:Iterators in JavaScript}
These two protocols explain how an object can be used for iteration in
JavaScript. An iterable object, also known as an iterable, represents a
collection of data. By calling a function on the iterator, we can access the
next element in the collection, moving in a single direction. Iterators can be
either finite or infinite. Once we reach the end of a finite iterator, it is
considered "used up," and subsequent calls to an exhausted iterator won't
produce any meaningful results. Below, we will provide a more detailed
description of these two protocols.

\subsubsection{The Iterable Protocol}
\label{subsub:The Iterable Protocol}

In JavaScript, an object is considered an iterable if it contains a property
called |[Symbol.iterator]|. This property signifies that the object is of type
|Iterable<T>|. When we invoke the |[Symbol.iterator]| property, it creates an
iterator that follows the iterator protocol explained in the following section.
Objects in JavaScript that implement this property can be utilized with
destructuring \footnote{The destructuring assignment syntax is a JavaScript
expression that allows to extract items of iterables into individual
variables.}and |for...of| loops. Listing \ref{lst:iterable_protocols}
showcases an example of an object defining the |[Symbol.iterator]| property.

\begin{lstlisting}[
  style=ES6, 
  caption=Iterable protocol,
  label={lst:iterable_protocols}
  ]
  return {
    [Symbol.iterator]: () => {
      return { next: next }; *'// next is defined in~\ref{lst:iterator_protocol}'*
    }
  }
\end{lstlisting}

\subsubsection{The Iterator Protocol}
\label{subsub:The Iterator Protocol}
Invoking the |[Symbol.iterator]| property obtains an iterator object
complying to the iterator protocol. It must implement a function |next|, which
defines how and which values are returned when iterating. Each iteration on an
iterator calls this function. |next| returns an object, which must
include two properties: |value| and |done|. The property |value|
contains the current value of the iteration, while |done| represents the
information on whether the end of the iteration has been reached. The following
code \ref{lst:iterator_protocol} shows a simple implementation of it. Each call
on |next| returns an object with the |value 1|. |done| is always |false|, so
the iteration never ends. 

\begin{lstlisting}[
  style=ES6, caption=Iterator protocol,
  label={lst:iterator_protocol}
  ]
  const next = () => {
    return { done: false, value: 1 };
  };
\end{lstlisting}

\subsubsection{Creating Iterables}
\label{subsub:Creating Iterables}
By combining these two protocols, the result could look like listing
\ref{lst:protocols}. The constructor |InfiniteOnesIterable| on
line~\ref{line:ctor_infiniteones} wraps the two
previously defined implementations. This constructor therefore returns iterable
objects. Since the return value is always one(|1|), this is an iterable of
type |Iterable<Number>|.

\begin{lstlisting}[
  style=ES6, caption=Iterable and iterator protocol,
  label={lst:protocols}
  ]
 const InfiniteOnesIterable = () => {*'\label{line:ctor_infiniteones}'*

  const next = () => {
    return { done: false, value: 1 };
  };

  return {
    [Symbol.iterator]: () => {
      return { next: next };
    }
  }
};

const [one, anotherOne, andOneAgain] = InfiniteOnesIterable();*'\label{line:infiniteones_destructuring}'*

for(one in InfiniteOnesIterable){
  ...
  break;
}*'\label{line:infiniteones_forof}'*


\end{lstlisting}

Because |InfiniteOnesIterable| adheres to the JS iteration protocols, it is now 
possible to create iterable objects. Language features like |for..of| and 
destructuring can process these objects as shown on line~\ref{line:infiniteones_destructuring}
to~\ref{line:infiniteones_forof}. However, beware of this 
case. This would lead to an infinite loop because the property |done| never 
becomes |true|. Therefore, the iteration never ends. We will see examples 
with non-endless iterables later in this work. 
For now, the focus here is on the protocols. Therefore, this 
example is sufficient at this point.
\newline
Such protocols make it possible to build customized iterables and
collections. This opens new possibilities. Various programming tasks can have 
different, more straightforward solving approaches in a more declarative way to
write.
There are already some JavaScript iterables present. Arrays and
|HTMLCollection|s are probably the most prominent of these.

\subsection{Types of Iterables}
\label{sub:Types of Iterables}
Previously we saw a distinction between iterables and iterators. These abstractions
also have their types. Listing \ref{lst:iterable_types} shows an excerpt of the
relevant types.

\begin{lstlisting}[
  style=ES6, caption=Types of iterables,
  label={lst:iterable_types}
  ]
// lib.es2015.iterable.d.ts

interface Iterable<T> {*'\label{line:start_iteration_types}'*
    [Symbol.iterator](): Iterator<T>;
}

interface Iterator<T, TReturn = any, TNext = undefined> {
  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    return?(value?: TReturn): IteratorResult<T, TReturn>;
    throw?(e?: any): IteratorResult<T, TReturn>;
}*'\label{line:end_iteration_types}'*

type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> *'\label{line:start_iteration_result_types}'*
                                      | IteratorReturnResult<TReturn>;


interface IteratorYieldResult<TYield> {
    done?: false;
    value: TYield;
}

interface IteratorReturnResult<TReturn> {
    done: true;*'\label{line:iteration_return_result_done}'*
    value: TReturn;
} *'\label{line:end_iteration_result_types}'*
\end{lstlisting}

\begin{itemize}
  \item{Line~\ref{line:start_iteration_types}~-~\ref{line:end_iteration_types}: 
      An |Iterable| is of type |Iterable<T>|, whereas the object returned by the property
      |[Symbol.Iterator]| is of type |Iterator<...>|. An |Iterator| requires having a property |next|. 
      This is the function that returns values when iterating. These values must be 
      of type |IteratorResult<...>.|
    }
  \item{Line~\ref{line:start_iteration_result_types}~-~\ref{line:end_iteration_result_types}:
      |IteratorResult<...>| itself is defined to return an 
      object of type |IteratorReturnResult<...>|, which either is of type
      |IteratorYieldResult| or |IteratorReturnResult|. This object contains the actual 
      values we want to work with.}
\end{itemize}

In chapter~\ref{subsub:Stateful Decorating}, we will see the reason for this
nested architecture of the JS iteration protocol.

\subsubsection{Closer Look to IteratorReturnResult}
\label{subsub:Closer look to IteratorReturnResult}
When iterating an iterable, the returned elements are of type
|IteratorYieldResult<T>|. The last and all following element of an iterable is of type
|IteratorReturnResult<TReturn>|. This ensures that |done| is set to |true|, as 
can be seen on line~\ref{line:iteration_return_result_done} in listing~\ref{lst:iterable_types}.


\subsection{Illustration of the JS Iteration Protocol}
\label{sub:Illustration of the JS Iteration Protocol}
Listing~\ref{lst:example_js_iteration_protocol} illustrates the behavior of the
JS iteration protocol more clearly using a sample scenario. Since array is an
iterable, we can use it for the following demonstration:

\begin{lstlisting}[
  style=ES6, 
  caption=Example: JS Iteration Protocol,
  label={lst:example_js_iteration_protocol}
  ]
// array including two values, 0 and 1
const list = [0, 1];
const iterator = list[Symbol.iterator]();*'\label{line:illustraion_create_iterator}'*

iterator.next(); // returns { done: false, value: 0 }
iterator.next(); // returns { done: false, value: 1 }
iterator.next(); // returns { done: true,  value: undefined }
iterator.next(); // returns { done: true,  value: undefined }
\end{lstlisting}

On line~\ref{line:illustraion_create_iterator}, invoking |[Symbol.iterator]|
returns iterator of the iterable |list|. 
After that, we call |next| four times directly on the iterator. Since the
iterable contains only two elements, the third and fourth call on |next|
returns an object of type |IteratorReturnResult<TReturn>|. Thereby, |done| is
|true| and |value| is |undefined|. \\
By using |for...of| and destructuring, an iterable would stop iterating at this
point. This means, an |for...of| loop runs until the property |done| is set to
|true|.

% \begin{figure}[H]
%   \centering
%   \begin{sequencediagram}                                                      
%     \newthread{client}{:Client}                                                        
%     \newinst[3]{iterable}{:Iterable}                                                     
%     \newinst[3]{iterator}{:Iterator}                                                     
% 
%     \begin{call}{client}{[Symbol.iteator()]}{iterable}{return Iterator<T>}                                  
%     \end{call}                                                                    
% 
%     \begin{call}{client}{next()}{iterator}{returns IteratorYieldResult<T>}                                  
%     \end{call}                                                                    
% 
%     \begin{call}{client}{next()}{iterator}{returns IteratorYieldResult<T>}                                  
%     \end{call}                                                                    
% 
%     \begin{call}{client}{next()}{iterator}{returns IteratorReturnResult<TReturn>}                                  
%     \end{call}                                                                    
% 
%     \begin{call}{client}{next()}{iterator}{returns IteratorReturnResult<TReturn>}                                  
%     \end{call}                                                                    
%   \end{sequencediagram}    
%   \caption{JS iteration protocol procedure}
%   \label{fig:js_iteration_protocol}
% \end{figure}

% Since |InfiniteOnesIterable| only contains two elements, the third and fourth element
% is of type |IteratorReturnResult<TReturn>|.

\subsection{Building custom Sequences of Data}
\label{sub:Building custom Sequences of Data}
The last section has shown how to make an object iterable, using an iterable
always returning one (|1|) as an example~(\ref{lst:protocols}). This section explains how to build more
powerful data structures based on these protocols by creating meaningful data
series.

\subsubsection{Sequence - The Name of connected Data}
\label{subsub:Sequence - The Name of connected Data}
In Computer Science, naming elements accurately poses a significant challenge 
when aiming to develop sustainable and robust code. We decided to name series
of data a "sequence". It has been influenced by several factors:

\begin{itemize}
  \item Sequences are not conventional lists known from other programming
    languages.
\item The name sequence is already known from mathematics.
\item Giving this data structure a more familiar name, for example "list",
  leads to wrong assumptions. 
\end{itemize}
What distinguishes the object generated by the sequence from the conventional
list is that a sequence generates its values when they are requested.
Therefore, it needs almost no memory. At the same time, you have the impression
that you are dealing with a vast amount of data. So the constructor |Sequence|
emerged, which generates such connected data.

\subsubsection{Components of a Sequence}
\label{subsub:Components of a Sequence}
Defining a sequence requires specifying three essential points:
\begin{enumerate}
  \item{A fixed starting value for the sequence} 
  \item{A function that determines whether the sequence should generate
    further values} 
  \item{A function to calculate the next value based on its predecessor} 
\end{enumerate}
These three elements define the sequence. Listing \ref{lst:sequence} on
line~\ref{line:seq_args} shows the passing of these three elements as arguments
to the constructor. To keep the focus on the core elements of the sequence,
some functionality in listing \ref{lst:sequence} is omitted and discussed later.
The |next| function, explained section~\ref{subsub:The Iterator Protocol}, is on
lines~\ref{line:start_protocol}~-~\ref{line:end_protocol}. It contains the
logic to return the next value in an iteration. First, it uses |whileFunction|
to check if the Sequence has finished. If this is not the case, the
|incrementFunction| calculates the next element, which afterward will be
returned.

\begin{lstlisting}[
  style=ES6, 
  caption=Parts of Sequence,
  label={lst:sequence}
  ]
// Sequence.js
const Sequence = (start, whileFunction, incrementFunction) => {*'\label{line:seq_args}'*

  const iterator = () => {
    let value = start;
    /**
     * @template _T_
     * Returns the next iteration of this iterable object.
     * @returns { IteratorResult<_T_, _T_> }
     */
    const next = () => {*'\label{line:start_protocol}'*
      const current = value;
      const done = !whileFunction(current);
      if (!done) value = incrementFunction(value);
      return { done, value: current };*'\label{line:end_protocol}'*
    };

    return { next };
  };

  return ... 
};
\end{lstlisting}


\subsubsection{Using a Sequence}
\label{subsub:Using a Sequence}
Listing \ref{lst:even-sequence} shows the definition of a sequence of even 
numbers smaller than ten and how to use it. 
\begin{lstlisting}[
  style=ES6, 
  caption=Sequence of even numbers,
  label={lst:even-sequence}
  ]
const startValue        = 0;
const whileFunction     = x => x < 10;
const incrementFunction = x => x + 2;

const seq = Sequence(startValue, whileFunction, incrementFunction);

for (const elem of seq) {
  console.log(elem);
}
// => Logs '0, 2, 4, 6, 8' *'\label{line:demo_output}'*
\end{lstlisting}

The |for..of| loop iterates over the sequence until |done| is true. Meanwhile,
|console.log| writes the elements to the console.
Line~\ref{line:demo_output} shows the output produced.

Now, we discussed the ability to generate arbitrary sequences of data. However, 
just creation is often not enough as there is a need to manipulate the data or 
introduce additional levels of abstraction. In the upcoming chapter, we will 
delve into processing such Sequences.
