\section{Sequence and Iterable in General}
\label{sec:Sequence and Iterable in General}
This section explains the concept of iterable objects and shows how to create 
them. Sequence is one such implementation. It illustrates how the benefits of 
iterators are utilized in a specific implementation using illustrations and 
explanations.

\subsection{What is an Iterator?}
\label{sub:What is an Iterator?}
Iterators are a common notion in computer science. An iterator is a mechanism 
to access elements of any data structure. It uses a function call to return the 
next element and either act on a data structure in memory or compute the 
elements when queried. Iterators are an essential part of this work. Therefore, 
the fundamentals are essential to understand, and the following sections cover
the topic in depth.

% \subsection{Iteration Protocols in JavaScript}
\subsection{Exploring the Meaning Of Protocols}
\label{sub:Exploring the Meaning Of Protocols}
In JavaScript, an iterator is an object that implements the JavaScript iterator
and iterable protocols \cite{mdn_iteration_2023}
(henceforth called JS iteration protocols). An iterator
has the characteristic of only iterating once across a collection of items.
After that, the iterator is exhausted, and the following operations will be
performed on a new instance.

\subsubsection{The Iterable Protocol}
\label{subsub:The Iterable Protocol}
An object is an iterable according to the JS iterable protocol if it has a
property with the name |[Symbol.iterator]|. Thus, such an object is of type
|Iterable<T>| which defines its iteration behavior.
All objects in JavaScript that have this property can be processed using 
destructuring and |for...of| loop. 
The sample code for defining a property named |[Symbol.iterator]| is shown
in Listing \ref{lst:iterable_protocols}. The value of this property is a
function which has to follow the iterator protocol.

\begin{lstlisting}[
  style=ES6, 
  caption=Iterable protocol,
  label={lst:iterable_protocols}
  ]
  return {
    [Symbol.iterator]: () => {
      return { next: next };
    }
  }
\end{lstlisting}

\subsubsection{The Iterator Protocol}
\label{subsub:The Iterator Protocol}
This protocol defines the structure of the iterator object. Invoking the 
|[Symbol.iterator]| property obtains such an object. These objects must 
implement a function next, which defines how and which values are returned 
when iterating.
Each iteration calls the function |next|. |next| returns an object, which must
have two properties according to the iterator protocol: |value| and |done|.
Therefore, the property |value| contains the current value of the iteration,
while |done| represents the information on whether the end of the iteration has 
been reached. The following code \ref{lst:iterator_protocol} shows a simple 
example implementation. Each call on |next| returns an object with the |value| 
1, and the iteration is never finished. 

\begin{lstlisting}[
  style=ES6, caption=Iterator protocol,
  label={lst:iterator_protocol}
  ]
  const next = () => {
    return { done: false, value: 1 };
  };
\end{lstlisting}

\subsubsection{Creating Iterables}
\label{subsub:Creating Iterables}
By combining the two protocols, the result could look like listing
\ref{lst:protocols}. In listing \ref{lst:protocols}, the constructor 
|SampleIterable| on line 1 wraps the two previously
defined implementations of the protocols. Objects from this constructor are now
iterables. It has the type |Iterable<Number>| because the return value from the
iterator is one.

\begin{lstlisting}[
  style=ES6, caption=Iterable and iterator protocol,
  label={lst:protocols}
  ]
 const SampleIterable = () => {

  const next = () => {
    return { done: false, value: 1 };
  };

  return {
    [Symbol.iterator]: () => {
      return { next: next };
    }
  }
};
\end{lstlisting}

Since |SampleIterator| follows the JS iterator protocols it is now possible to 
construct iterable objects. Built-in language features like |for..of| and 
destructuring (|...|) can now process these objects. However, beware in this 
case. This would lead to an infinite loop because the property done never 
becomes true. We will see examples with non-endless iterators later in this. 
Nevertheless, for now, the focus here is on the protocols. Therefore this 
example will be sufficient at this point.
\newline
Such protocols make it possible to iterate your customized objects and
collections. This opens new possibilities. Various programming tasks can be 
solvable differently, probably more straightforwardly.\newline
There are already some languages built-in iterable in JavaScript. Array and
HTML Collections are probably the most prominent of these.

\subsection{Types of Iterables}
\label{sub:Types of Iterables}
Previously we saw a distinction between 
iterables~\ref{subsub:Creating Iterables} and 
iterator~\ref{subsub:The Iterator Protocol}. These abstractions also have their 
types. Listing \ref{lst:iterable_types} shows an excerpt of the relevant types.

\begin{lstlisting}[
  style=ES6, caption=Types of iterables,
  label={lst:iterable_types}
  ]
// lib.es2015.iterable.d.ts

interface Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}

interface Iterator<T, TReturn = any, TNext = undefined> {
    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    return?(value?: TReturn): IteratorResult<T, TReturn>;
    throw?(e?: any): IteratorResult<T, TReturn>;
}

type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> 
                                      | IteratorReturnResult<TReturn>;

interface IteratorReturnResult<TReturn> {
    done: true;
    value: TReturn;
}
\end{lstlisting}

An iterable is of type |Iterable<T>|, whereas the object returned by the property
|[Symbol.Iterator]| is of type |Itertator<...>|. As shown in listing
\ref{lst:iterable_types}, an iterator is required to have a property next. 
This is the function that returns values when iterating. These values must be 
of type |IteratorResult<...>|, defined on line 8 of listing 
\ref{lst:iterable_types}. |IteratorResult<...>| itself is defined to return an 
object of type |ItereratorReturnResult<...>|. This object contains the actual 
values we want to work with. Examining these types illustrates how JavaScript's 
iterators have been built and reveal that some objects are nested within each
other. There is a reason for this. We will get to the roots of these in
chapter~\ref{sub:Stateful Decorating}.

\subsection{Building custom Series of Data}
\label{sub:Building custom Series of Data}
The last chapter has shown how to make an object iterable. By exploring the 
protocols discussed so far, this chapter showcases the ability to create 
powerful concepts. Previously, an endless iterator that generates only ones 
served as an illustration. The goal is to create a constructor that can 
produce arbitrary data series.

\subsection{Sequence - The Name of connected Data}
\label{sub:Sequence - The Name of connected Data}
As is often the case in computer science, finding the proper names is one of 
the hardest things in programming sustainable and robust code. Various arguments 
have contributed to the fact that the constructor for creating any series is 
called "Sequence". First, sequences are not conventional lists known from other 
programming languages. However, it must be clear from the name that it is about 
connected data. Second, it carries a small risk of introducing new names and
thus discourages users. However, we chose the name because it was important not
to make false assumptions about what we were working with. 
\newline
The nice thing about the objects generated by Sequence compared to
conventional lists is that one has the feeling of handling large 
amounts of data arbitrarily. In reality, however, only a minimum of memory is 
needed because the subsequent elements are not yet in memory.

\subsection{Everything a Sequence needs}
\label{sub:Everything a Sequence needs}
Defining a Sequence of data requires specifying three essential points:
\begin{enumerate}
  \item{A fixed starting value for the Sequence} 
  \item{A function to calculate the next element based on its predecessor} 
  \item{A function to determine if the Sequence has reached its end} 
\end{enumerate}
These three elements define the Sequence and are passed as arguments, 
see listing \ref{lst:sequence} line~\ref{line:seq_args}.
To keep the focus on the core elements of the Sequence, some functionality in 
listing \ref{lst:sequence} is discussed later. The |next| function, explained in 
the Iterator Protocol section~\ref{subsub:The Iterator Protocol}, 
is on lines~\ref{line:start_protocol}~-~\ref{line:end_protocol}. It contains the 
logic to return the next object of an iteration. First, it uses |untilFunction| 
to check if the Sequence has finished. If this is not the case, the
|incrementFunction| calculates the next element and returns it.

\begin{lstlisting}[
  style=ES6, 
  caption=Parts of Sequence,
  label={lst:sequence}
  ]
// Sequence.js
const Sequence = (start, untilFunction, incrementFunction) => {*'\label{line:seq_args}'*

  const iterator = () => {
    let value = start;
    /**
     * @template _T_
     * Returns the next iteration of this iterable object.
     * @returns { IteratorResult<_T_, _T_> }
     */
    const next = () => {*'\label{line:start_protocol}'*
      const current = value;
      const done = !untilFunction(current);
      if (!done) value = incrementFunction(value);
      return { done, value: current };*'\label{line:end_protocol}'*
    };

    return { next };
  };

  return createMonadicSequence(iterator);
};
\end{lstlisting}


\subsubsection{Using a Sequence}
\label{subsub:Using a Sequence}
Listing \ref{lst:even-sequence} shows the definition of a sequence of even 
numbers smaller than ten and how to use it. 
\begin{lstlisting}[
  style=ES6, 
  caption=Sequence over the even numbers,
  label={lst:even-sequence}
  ]
const startValue        = 0;
const untilFunction     = x => x < 10;
const incrementFunction = x => x + 2;

const seq = Sequence(startValue, untilFunction, incrementFunction);

for (const elem of seq) {
  console.log(elem);
}

// => Logs '0, 2, 4, 6, 8' *'\label{line:demo_output}'*
\end{lstlisting}

The |for..of| loop iterates over each
element until |done| is true. Meanwhile, |console.log| writes the elements out 
to the console. Line~\ref{line:demo_output} shows the output produced.
\newline

Now, we discussed the ability to generate arbitrary sequences of data. However, 
just creation is often inadequate as there is a need to manipulate the data or 
introduce additional levels of abstraction. In the upcoming chapter, we will 
delve into processing such sequences.
