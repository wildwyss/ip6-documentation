\section{Sequence and Iterable in General}
\label{sec:Sequence and Iterable in General}
This section explains the concept of iterable and iterator objects and points
out features and characteristics of it. |Sequence| is one implementation of
an iterable and represents the core functionality of the Sequence Library. The following
discussion covers challenges and solutions for creating a robust and
user-friendly API.

\subsection{What is an Iterator?}
\label{sub:What is an Iterator?}
In computer science, iterators are a popular concept. An iterator is a mechanism 
to access elements of any data structure. It uses a function call to return the 
next element and either acts on a data structure in memory or compute the 
elements lazily when queried. Iterators are an essential part of this work. Therefore, 
the fundamentals are essential to understand. The following sections cover
this topic in depth.

% \subsection{Iteration Protocols in JavaScript}
\subsection{Exploring the Meaning of Protocols}
\label{sub:Exploring the Meaning of Protocols}
In JavaScript, an |iterable| is an object that implements the JavaScript iterator
and iterable protocols \cite{mdn_protocols}
(henceforth called JS iteration protocols). An |iterable| iterates only once 
over a set of data. After that, the |iterable| is exhausted. Further operations 
will only perform on a new instance of it.
\newline
To create an iterator, implementing the two following protocols is required.

\subsubsection{The Iterable Protocol}
\label{subsub:The Iterable Protocol}
An object is an iterable according to the JS iterable protocol if it has a
property with the name |[Symbol.iterator]|. This property defines the iteration
behavior of the object. Such an object is of type |Iterable<T>|.
All objects in JavaScript that implement this property can be processed using 
destructuring\footnote{The destructuring assignment syntax is a JavaScript
expression that allows you to extract array items or object properties into
individual variables.} and |for...of| loop. 
Listing \ref{lst:iterable_protocols} demonstrates how an object defines a
|[Symbol.iterator]| property.
This property's value is a function that must adhere to the iterator protocol.
It is content of the next section.

\begin{lstlisting}[
  style=ES6, 
  caption=Iterable protocol,
  label={lst:iterable_protocols}
  ]
  return {
    [Symbol.iterator]: () => {
      return { next: next }; *' defined in~\ref{subsub:The Iterator Protocol}'*
    }
  }
\end{lstlisting}

\subsubsection{The Iterator Protocol}
\label{subsub:The Iterator Protocol}
Invoking the |[Symbol.iterator]| property obtains an iterator object.
This protocol defines the structure of such an object. It must 
implement a function |next|, which defines how and which values are returned 
when iterating.
Each iteration on an |iterator| calls the function |next|. |next| returns an object, which must
include two properties according to the iterator protocol: |value| and |done|.
Therefore, the property |value| contains the current value of the iteration,
while |done| represents the information on whether the end of the iteration has 
been reached. The following code \ref{lst:iterator_protocol} shows a simple 
implementation of it. Each call on |next| returns an object with the |value| 
|1|. |done| is always |false|, so the iteration never ends. 

\begin{lstlisting}[
  style=ES6, caption=Iterator protocol,
  label={lst:iterator_protocol}
  ]
  const next = () => {
    return { done: false, value: 1 };
  };
\end{lstlisting}

\subsubsection{Creating Iterables}
\label{subsub:Creating Iterables}
By combining the two protocols, the result could look like listing
\ref{lst:protocols}. The constructor |SampleIterable| on line 1 wraps the two previously
defined implementations of the protocols. Objects returned by this constructor 
are now |Iterables|. Since the return value is always a |Number|, the object type
is |Iterable<Number>|.

\begin{lstlisting}[
  style=ES6, caption=Iterable and iterator protocol,
  label={lst:protocols}
  ]
 const SampleIterable = () => {

  const next = () => {
    return { done: false, value: 1 };
  };

  return {
    [Symbol.iterator]: () => {
      return { next: next };
    }
  }
};
\end{lstlisting}

Because |SampleIterator| adheres to the JS iteration protocols, it is now 
possible to create iterable objects. Language features like |for..of| and 
destructuring (|...|) can now process these objects. However, beware of this 
case. This would lead to an infinite loop because the property |done| never 
becomes |true|. Therefore, the iteration never ends. We will see examples 
with non-endless |Iterable|s later in this work. 
For now, the focus here is on the protocols. Therefore, this 
example is sufficient at this point.
\newline
Such protocols make it possible to build your customized |Iterable|s and
collections. This opens new possibilities. Various programming tasks can have 
different, more straightforward solving approaches in a more declarative way to
write.
There are already some JavaScript |Iterable|s present. |array|s and
|HTML Collection|s are probably the most prominent of these.

\subsection{Types of Iterables}
\label{sub:Types of Iterables}
Previously we saw a distinction between 
|Iterable|s~\ref{subsub:Creating Iterables} and 
|Iterator|s~\ref{subsub:The Iterator Protocol}. These abstractions also have their 
types. Listing \ref{lst:iterable_types} shows an excerpt of the relevant types.

\begin{lstlisting}[
  style=ES6, caption=Types of iterables,
  label={lst:iterable_types}
  ]
// lib.es2015.iterable.d.ts

interface Iterable<T> {*'\label{line:start_iteration_types}'*
    [Symbol.iterator](): Iterator<T>;
}

interface Iterator<T, TReturn = any, TNext = undefined> {
  next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    return?(value?: TReturn): IteratorResult<T, TReturn>;
    throw?(e?: any): IteratorResult<T, TReturn>;
}*'\label{line:end_iteration_types}'*

type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> *'\label{line:start_iteration_result_types}'*
                                      | IteratorReturnResult<TReturn>;


interface IteratorYieldResult<TYield> {
    done?: false;
    value: TYield;
}

interface IteratorReturnResult<TReturn> {
    done: true;*'\label{line:iteration_return_result_done}'*
    value: TReturn;
} *'\label{line:end_iteration_result_types}'*
\end{lstlisting}

\begin{itemize}
  \item{Line~\ref{line:start_iteration_types}~-~\ref{line:end_iteration_types}: 
      An iterable is of type |Iterable<T>|, whereas the object returned by the property
      |[Symbol.Iterator]| is of type |Iterator<...>|. An iterator requires having a property |next|. 
      This is the function that returns values when iterating. These values must be 
      of type |IteratorResult<...>.|
    }
  \item{Line~\ref{line:start_iteration_result_types}~-~\ref{line:end_iteration_result_types}:
      |IteratorResult<...>| itself is defined to return an 
      object of type |IteratorReturnResult<...>|, which either is of type
      |IteratorYieldResult| or |IteratorReturnResult|. This object contains the actual 
      values we want to work with.}
\end{itemize}

In Chapter~\ref{subsub:Stateful Decorating}, we will see the reason for this
nested architecture of the JS iteration protocol.

\subsubsection{Closer look to IteratorReturnResult}
\label{subsub:Closer look to IteratorReturnResult}
When iterating an |Iterable|, the returned elements are of type
|IteratorYieldResult<T>|. The last element of an iteration is then of type
|IteratorReturnResult<TReturn>|. All further calls on an already exhausted
|Iterable| are of this type. This ensures that |done| is set to |true|, as 
can be seen on line~\ref{line:iteration_return_result_done}.


\subsection{Illustration of the JS Iteration Protocol}
\label{sub:Illustration of the JS Iteration Protocol}
Following an example scenario in Listing~\ref{lst:example_js_iteration_protocol}
to illustrate the behavior of the JS iterable protocol more clearly.

\begin{lstlisting}[
  style=ES6, 
  caption=Example: JS Iteration Protocol,
  label={lst:example_js_iteration_protocol}
  ]
const seq = Sequence(0, x => x < 2, x =>  x + 1); 
const iterator = seq[Symbol.iterator]();*'\label{line:illustraion_create_iterator}'*

iterator.next(); // returns { done: false, value: 0 }
iterator.next(); // returns { done: false, value: 1 }
iterator.next(); // returns { done: true,  value: 2 }
iterator.next(); // returns { done: true,  value: 2 }
\end{lstlisting}

On line~\ref{line:illustraion_create_iterator}, invoking |[Symbol.iterator]|
returns an instance of an |Iterator| of the |Iterable| |seq|. 
After that, we call |next| four times directly on the |Iterator|. 
This leads to the following diagram~\ref{fig:js_iterable_protocol} shown below. 

\begin{figure}[H]
  \centering
  \begin{sequencediagram}                                                      
    \newthread{client}{:Client}                                                        
    \newinst[3]{iterable}{:Iterable}                                                     
    \newinst[3]{iterator}{:Iterator}                                                     

    \begin{call}{client}{[Symbol.iteator()]}{iterable}{return Iterator<T>}                                  
    \end{call}                                                                    

    \begin{call}{client}{next()}{iterator}{returns IteratorYieldResult<T>}                                  
    \end{call}                                                                    

    \begin{call}{client}{next()}{iterator}{returns IteratorYieldResult<T>}                                  
    \end{call}                                                                    

    \begin{call}{client}{next()}{iterator}{returns IteratorReturndResult<TReturn>}                                  
    \end{call}                                                                    

    \begin{call}{client}{next()}{iterator}{returns IteratorReturndResult<TReturn>}                                  
    \end{call}                                                                    
  \end{sequencediagram}    
  \caption{JS iterable protocol procedure}
  \label{fig:js_iterable_protocol}
\end{figure}

Since |SampleSequence| only contains three elements, the third
and fourth element is of type |IteratorReturnResult<TReturn>|.

\subsection{Building custom Series of Data}
\label{sub:Building custom Series of Data}
The last Chapter has shown how to make an object iterable. By exploring the 
protocols discussed so far, this chapter showcases the ability to create 
powerful concepts. Based on these abstractions, an endless iterator that always
returns |1| served as an illustration. The true power of |Iterable|s is 
unleashed, when they create more meaningful data series
\subsubsection{Sequence - The Name of connected Data}
\label{subsub:Sequence - The Name of connected Data}
In computer science, naming elements accurately poses a significant challenge 
when aiming to develop sustainable and robust code. We decided to name series
of data a "Sequence". It has been influenced by several factors:

\begin{itemize}
  \item{Sequences are not conventional lists known from other programming languages}
  \item{It contains interrelated data}
  \item{Having the courage to introduce an unfamiliar name, with the risk of increasing the barrier to use}
\end{itemize}

The name "Sequence" avoids making incorrect assumptions about the nature of
this data structure.
\newline
What distinguishes the object generated by the Sequence from conventional list
is the fact, that it needs almost no memory since values are generated. At the 
same time, you have the impression that you are dealing with huge amounts of data.
So the constructor |Sequence| emerged, which generates such connected data.

\subsubsection{Components of a Sequence}
\label{subsub:Components of a Sequence}
Defining a Sequence requires specifying three essential points:
\begin{enumerate}
  \item{A fixed starting value for the Sequence} 
  \item{A function that determines whether the Sequence should still generate
    some values} 
  \item{A function to calculate the next element based on its predecessor} 
\end{enumerate}
These three elements define the Sequence. Listing \ref{lst:sequence} on
line~\ref{line:seq_args} shows the passing arguments to the constructor.
To keep the focus on the core elements of the Sequence, some functionality in 
listing \ref{lst:sequence} is discussed later. The |next| function, explained in 
the Iterator Protocol section~\ref{subsub:The Iterator Protocol}, 
is on lines~\ref{line:start_protocol}~-~\ref{line:end_protocol}. It contains the 
logic to return the next object of an iteration. First, it uses |untilFunction| 
to check if the Sequence has finished. If this is not the case, the
|incrementFunction| calculates the next element, which afterward will be
returned.

\begin{lstlisting}[
  style=ES6, 
  caption=Parts of Sequence,
  label={lst:sequence}
  ]
// Sequence.js
const Sequence = (start, untilFunction, incrementFunction) => {*'\label{line:seq_args}'*

  const iterator = () => {
    let value = start;
    /**
     * @template _T_
     * Returns the next iteration of this iterable object.
     * @returns { IteratorResult<_T_, _T_> }
     */
    const next = () => {*'\label{line:start_protocol}'*
      const current = value;
      const done = !untilFunction(current);
      if (!done) value = incrementFunction(value);
      return { done, value: current };*'\label{line:end_protocol}'*
    };

    return { next };
  };

  return ... 
};
\end{lstlisting}


\subsubsection{Using a Sequence}
\label{subsub:Using a Sequence}
Listing \ref{lst:even-sequence} shows the definition of a sequence of even 
numbers smaller than ten and how to use it. 
\begin{lstlisting}[
  style=ES6, 
  caption=Sequence of even numbers,
  label={lst:even-sequence}
  ]
const startValue        = 0;
const untilFunction     = x => x < 10;
const incrementFunction = x => x + 2;

const seq = Sequence(startValue, untilFunction, incrementFunction);

for (const elem of seq) {
  console.log(elem);
}

// => Logs '0, 2, 4, 6, 8' *'\label{line:demo_output}'*
\end{lstlisting}

The |for..of| loop iterates over each
element until |done| is true. Meanwhile, |console.log| writes the elements out 
to the console. Line~\ref{line:demo_output} shows the output produced.
\newline

Now, we discussed the ability to generate arbitrary sequences of data. However, 
just creation is often not enough as there is a need to manipulate the data or 
introduce additional levels of abstraction. In the upcoming chapter, we will 
delve into processing such Sequences.
