\section{Monads in JavaScript} % (fold)
\label{sec:Monads in JavaScript}

\subsection{Wrapping values in a context} % (fold)
\label{sub:Wrapping values in a context}

In Haskell, you often work with values wrapped in a particular context. This
context can be, for example, a list. Nevertheless, this context can also be
another data structure, for example, |Maybe|. \\
For the context |Maybe| two implementations in Haskell co-exist:

% section Monads in JavaScript (end)
\begin{lstlisting}[
  style=Haskell,
  caption=The data type Maybe in Haskell,
  label={lst:maybe_hs}
]
-- defining the datatype Maybe
data Maybe a = Nothing | Just a
\end{lstlisting}

The Listing~\ref{lst:maybe_hs} defines this datatype. Why is this useful?
Imagine you want to create a function |head|, which returns the first value of
a given list. |head| is pretty simple to implement. But wait, what to do when
the list is empty? In object-oriented languages, one might return |null|. The
problem with this solution is that the user must remember that the list can be
empty, and thus the result of |head| can be |null|. This is very error-prone.
\\

That is where the new datatype |Maybe| comes in. |Maybe| allows us to describe
either the absence of a value or the value itself. The following
Listing~\ref{lst:safe_head} defines a new function |safeHead|
(line~\ref{line:safe_head1}), which does
precisely this - it returns |Just a| when the list is not empty
(line~\ref{line:safe_head2}) and |Nothing| otherwise (line~\ref{line:safe_head3}):

\begin{lstlisting}[
  style=Haskell,
  caption=Safely get the first element of a list,
  label={lst:safe_head}
]
-- a function which produces a Maybe:
safeHead :: [a] -> Maybe a *'\label{line:safe_head1}'*
safeHead (a:_) = Just a *'\label{line:safe_head2}'*
safeHead []    = Nothing *'\label{line:safe_head3}'*

printHead list = print $ case (safeHead list) of 
  Just val -> show val
  Nothing  -> "List was empty!"

printHead [1,2,3,4]
-- Prints '"1"'
printHead []
-- Prints '"List was empty!"'
\end{lstlisting}

The difference with returning just |null| is that the user now has to
explicitly deal with the case where there is no first element. This leads to
improved safety.
% subsection Wrapping values in a context (end)

\subsection{Working with values in a context} % (fold)
\label{sub:Working with values in a context}
\subsubsection{Introducing fmap} % (fold)
\label{subsub:Introducing fmap}
The example with |Maybe| shows how values work in a context. Over time,
however, it can become tedious to keep making this distinction between whether
it has value. Therefore, Haskell offers a concept of working with values in a
context. The simplest way to work with the value using this concept is using
the function |fmap|. |fmap| knows how to execute a function for the value(s) in
a context. Listing~\ref{lst:fmap_maybe_hs} shows the usage of |fmap| for
|Maybe|:

\begin{lstlisting}[
  style=Haskell,
  caption=fmap applied to Maybe,
  label={lst:fmap_maybe_hs}
]
double = (\x -> 2*x)
print $ fmap double (Just 5)
-- Prints 'Just 10' 
print $ fmap double Nothing
--> Prints 'Nothing'
\end{lstlisting}

Similar to |Maybe| also lists describe such a context.
Listing~\ref{lst:hs_fmap_list} shows how |fmap| works on lists:

\begin{lstlisting}[
  style=Haskell,
  caption=fmap applied to a list,
  label={lst:hs_fmap_list}
]
print $ fmap double [1,2,3,4,5]
--> Prints '[2,4,6,8,10]'
\end{lstlisting}

Applying |fmap| to a list has the same result as applying |map| to a list.
Therefore, |fmap| is just a way to "map values".

% subsubsection Introducing fmap (end)
\subsubsection{Making a Context Monadic} % (fold)
\label{sec:Making a Context Monadic}
Haskell defines many other functions analogous to |fmap| to interact with
values in a context. Some of them are more powerful than |fmap|. The following
section gives a brief overview of which operations exist on monads. For a
detailed introduction to this topic, see, for example, HELLOWORLD. \\

If the context supports the following operations, it is considered monadic:

\begin{itemize}
  \item \textbf{Functor}: A context |f| is a |Functor| when it provides a function
|fmap|. |fmap| receives another function as an argument and applies it to the
value(s) in the context.\\
\item \textbf{Applicative}: A context |f| is an |Applicative| when it is a |Functor|
and additionally provides two functions:
\begin{itemize}
  \item |<*>| (pronounced "app") receives another function as an
    argument wrapped in the same context and applies the unwrapped function to
    the value(s) in the context.
  \item |pure| receives a single argument and wraps it in the context \\
\end{itemize}
\item \textbf{Monad}: A context |f| is a |Monad| when it is an |Applicative| and
additionally provides a function |>>=| (pronounced "bind"). |>>=| takes another
function as an argument which, when applied to the value(s), again creates a
value in the same context. So that the value(s) are not nested in the context,
|>>=| resolves the inner context again.
\end{itemize}

Some of these functions have special rules they must follow. Chapter "TODO link
chapter" discusses these rules using their corresponding JavaScript
implementation.
% subsubsection Making a Context Monadic (end)
\subsubsection{Why using these constraints?} % (fold)
\label{sec:Why using these constraints?}
These constraints allow building general functions that can handle various
types. Listing~\ref{lst:hs_why_use_constraints} shows a function |doubleAll|
applicable to |List|s and also |Maybe|s:

\begin{lstlisting}[
  style=Haskell,
  caption=Double the values in a context,
  label={lst:hs_why_use_constraints}
]
doubleAll :: (Functor f) => f Int -> f Int
doubleAll = fmap double

print $ doubleAll [1,2,3,4]
-- Prints '[2,4,6,8]'
print $ doubleAll $ Just 1
-- Prints 'Just 2'
\end{lstlisting}

Even though a |List| and a |Maybe| have nothing in common, the same function
can be applied to both types! \\ 
\textit{Note:} Another example that makes use of this is JINQ, which is described in the
section "TODO link section here".

% subsubsection Why using these constraints? (end)
% subsection Working with values in a context (end)

\subsection{Monads in JavaScript} % (fold)
\label{sub:Monads in JavaScript}
Since monads are so good at handling values in a context, this concept is also
interesting for JavaScript. However, JavaScript has a weaker type system than
Haskell. Therefore, two important concepts can not be transferred to
JavaScript: 
\begin{enumerate}
  \item In Haskell, it is possible, to force the type hierarchy hinted in
    Section~\ref{sec:Making a Context Monadic}.
  \item Haskell can use its type system to determine a specific implementation
    for a function. The Listing~\ref{lst:hs_fn_body} shows the binding of the
    function body to the name using the example of |fmap|:
    \begin{lstlisting}[
      style=Haskell,
      caption=Haskell determines the correct function body,
      label={lst:hs_fn_body}
    ]
    -- The implementation for List is used
    print $ fmap double [1,2,3,4]
    -- The implementation for Maybe is used
    print $ fmap double (Just 1)
    \end{lstlisting}
\end{enumerate}


Since it is not possible to implement these two concepts in JavaScript, a
different approach to these two problems is needed:
\begin{enumerate}
  \item Since JavaScript can not enforce type hierarchy, we created only one
    type, the |MonadType|. This type combines all operations a type needs to be
    monadic.
  \item Instead of type inference and global functions, we added all operations
    to the corresponding object's prototype.
\end{enumerate}

% subsection Monads in JavaScript (end)
