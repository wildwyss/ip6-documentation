\chapter{API}
\label{chap:app_API}

\newcommand{\passthrough}[1]{#1}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\hypertarget{api}{%
\section{Sequence Library}\label{api}}

\hypertarget{fa229d10-532a-4f04-9805-8fdc4881587a}{%
\subsection{Constructors}\label{sub:appendix_constructors} }

All functions listed below create new
\passthrough{\lstinline!Sequence!}s from non-sequence values. They are
therefore called constructors.

\hypertarget{6a313d03-9822-4a0c-a825-1a6a51264d55}{%
\subsubsection{Sequence}\label{6a313d03-9822-4a0c-a825-1a6a51264d55}}

The \passthrough{\lstinline!incrementFunction!} should change the value
(make progress) in a way that the \passthrough{\lstinline!ntilFunction!}
function can recognize the end of the sequence.

Contract:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!incrementFunction!} \&
  \passthrough{\lstinline!untilFunction!} should not refer to any
  mutable state variable (because of side effect) in the closure.
\end{itemize}

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!start!} & \passthrough{\lstinline!Number!} & the
first value to be returned by this sequence \\
\passthrough{\lstinline!untilFuncion!} &
\passthrough{\lstinline!(\_T\_) => Boolean!} & returns false if the
iteration should stop \\
\passthrough{\lstinline!incrementFunction!} &
\passthrough{\lstinline!(\_T\_) => T!} & calculates the next value based
on the previous \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=559ccb9f-6cec-4f05-b202-041bc70395bf]
const start      = 0;
const untilF     = x => x < 3;
const incrementF = x => x + 1;
const sequence   = Sequence(start, untilF, incrementF);
                                                       
console.log(...sequence);
// => Logs '0, 1, 2'
\end{lstlisting}

\hypertarget{eb038883-6cbc-4daf-ad04-f8c2e25f9a33}{%
\subsubsection{nil}\label{eb038883-6cbc-4daf-ad04-f8c2e25f9a33}}

This constant represents a sequence with no values in it.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<*>!}

\textbf{Example}

\begin{lstlisting}[label=5c45c9fa-4663-4eae-8965-8bea240591b4]
const emptySequence = nil;
                              
console.log(...emptySequence);
// => Logs '' (nothing)
\end{lstlisting}

\hypertarget{c35d49b1-5a40-4fb7-b9cd-225357873654}{%
\subsubsection{PureSequence}\label{c35d49b1-5a40-4fb7-b9cd-225357873654}}

Creates a Sequence which contains just the given value.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!value!} & \passthrough{\lstinline!\_T\_!} & The
single value \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=2effd3f2-45c8-4259-a1bd-334cff141bed]
const seq = PureSequence(1);
                            
console.log(...seq);
// => Logs '1'
\end{lstlisting}

\hypertarget{f195d9e4-f348-46ee-9ddf-a56012126598}{%
\subsubsection{repeat}\label{f195d9e4-f348-46ee-9ddf-a56012126598}}

Returns a Sequene that will repeatedly yield the value of
\passthrough{\lstinline!arg!} when iterated over.
\passthrough{\lstinline!repeat!} will never be exhausted.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!arg!} & \passthrough{\lstinline!\_T\_!} & The
value to repeat. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bd4ef248-0e38-4975-9d86-0bd39d562690]
const ones   = repeat(1);
const result = take(3)(ones);
                             
console.log(...result);
// => Logs '1, 1, 1'
\end{lstlisting}

\hypertarget{deb72945-4996-448f-a8dc-5256934ab44c}{%
\subsubsection{replicate}\label{deb72945-4996-448f-a8dc-5256934ab44c}}

\passthrough{\lstinline!replicate(n)(x)!} creates a Sequence of length
\passthrough{\lstinline!n!} with \passthrough{\lstinline!x!} the value
of every element.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!n!} & \passthrough{\lstinline!Number!} & How
many times the valued should be repeated \\
\passthrough{\lstinline!x!} & \passthrough{\lstinline!\_T\_!} & The
value to repeat \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=ccbcf172-af5e-478c-8044-fbe706545e55]
const trues = replicate(3)(true);
                                 
console.log(...trues);
// => Logs 'true, true, true'
\end{lstlisting}

\hypertarget{46837924-fa5a-4411-ba84-7dea9a3152bc}{%
\subsubsection{StackSequence}\label{46837924-fa5a-4411-ba84-7dea9a3152bc}}

Creates a \passthrough{\lstinline!SequenceType!} on top of the given
\passthrough{\lstinline!stack!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!stack!} & \passthrough{\lstinline!stack!} & Each
iteration returns the next element of this stack. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=4970f526-c453-4fad-a16a-c8a8cf65dbfd]
const stack         = push(push(push(emptyStack)(1))(2))(3);
const stackSequence = StackSequence(stack);
                                                            
console.log(...stackSequence);
// => Logs: '3, 2, 1'
\end{lstlisting}

\hypertarget{fcc27098-0cc2-44bc-98e9-51b45c2612d4}{%
\subsubsection{TupleSequence}\label{fcc27098-0cc2-44bc-98e9-51b45c2612d4}}

Constructs a new \passthrough{\lstinline!SequenceType!} based on the
given tuple.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} &
\passthrough{\lstinline!(f:ArrayApplierType<\_T\_>) => any!} & Each
iteration returns an element of the tuple. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=d339d35f-afff-4109-a8f7-348b7f8d90b4]
const [Triple]      = Tuple(3);
const triple        = Triple(1)(2)(3);
const tupleSequence = TupleSequence(triple);
                                            
console.log(...tupleSequence);
// => Logs '1, 2, 3'
\end{lstlisting}

\hypertarget{ed041adb-4774-4c16-a585-05c2eaf8e235}{%
\subsection{Special Constructors}\label{sub:appendix_special_constructors}}


\hypertarget{68f6afbc-de45-4843-9b8c-ab5ca8806c10}{%
\subsubsection{AngleSequence}\label{68f6afbc-de45-4843-9b8c-ab5ca8806c10}}

Creates a Sequence which generates evenly spaced angles between 0 and
360.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<Number>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} & \passthrough{\lstinline!Number!} & the
amount of angles to create. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b94dc362-c081-4bfa-9d61-5c838e57a755]
const angles = AngleSequence(4);
                                
console.log(...angles);
// Logs => '0, 90, 180, 270'
\end{lstlisting}

\hypertarget{94f121b1-5195-4c3d-9814-bd0d04af5c3d}{%
\subsubsection{FibonacciSequence}\label{94f121b1-5195-4c3d-9814-bd0d04af5c3d}}

Generates the Fibonacci sequence.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<Number>!}

\textbf{Example}

\begin{lstlisting}[label=6c80be8d-46ac-46b5-8bb9-055c77fa5a32]
const fibonacciNumbers = FibonacciSequence();
const result           = take(8)(fibonacciNumbers);
                                                   
console.log(...result);
// => Logs '1, 1, 2, 3, 5, 8, 13, 21'
\end{lstlisting}

\hypertarget{1984969b-ab43-4b4e-9089-49211b60162c}{%
\subsubsection{PrimeNumberSequence}\label{1984969b-ab43-4b4e-9089-49211b60162c}}

Generates the sequence of prime numbers.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<Number>!}

\textbf{Example}

\begin{lstlisting}[label=177f3653-2cbd-4c00-86df-09f69914c634]
const primeNumbers = PrimeNumberSequence();
const primes       = take(4)(primeNumbers);
                                           
console.log(...primes);
// => Logs '2, 3, 5, 7'
\end{lstlisting}

\hypertarget{ba6a35dc-6b39-4e8d-9ab5-f04ec32009b3}{%
\subsubsection{SquareNumberSequence}\label{ba6a35dc-6b39-4e8d-9ab5-f04ec32009b3}}

Generates the sequence of square numbers.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<Number>!}

\textbf{Example}

\begin{lstlisting}[label=c165f899-ffa4-43ac-bf8a-3fe162f8bcb1]
const squares = SquareNumberSequence();
const result  = take(5)(squares);
                                       
console.log(...result);
// => Logs '1, 4, 9, 16, 25'
\end{lstlisting}

\hypertarget{569b08a0-06b3-45e3-b4e9-576f534c5301}{%
\subsection{Operators}\label{sub:appendix_operators} }

All of the following functions operate on
\passthrough{\lstinline!Sequence!}s and
\passthrough{\lstinline!Iterble!}s. They all return a new
\passthrough{\lstinline!Sequence!}.

\hypertarget{ac6d2b03-9c43-4e0e-8308-92102a526003}{%
\subsubsection{bind}\label{ac6d2b03-9c43-4e0e-8308-92102a526003}}

Applies the given function to each element of the
\passthrough{\lstinline!Iterable!} and flats it afterward. @Note This
operation adds a monadic API to the
\passthrough{\lstinline!SequenceType!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!bindFn!} &
\passthrough{\lstinline!<\_U\_>(bindFn: (\_T\_) => Iterable<\_U\_>)!} &
This function will be applied to each element of the
\passthrough{\lstinline!Iterable!} \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=88beac1a-9eb8-42b2-b315-c2e69ef8bdbf]
const numbers = [0, 1, 2, 3];
const bindFn  = el => take(el)(repeat(el));
const result  = bind(bindFn)(numbers);
                                           
console.log(...result);
// => Logs '1, 2, 2, 3, 3, 3'
\end{lstlisting}

\hypertarget{341a8910-fef6-491a-ad04-e13dbd302b95}{%
\subsubsection{catMaybes}\label{341a8910-fef6-491a-ad04-e13dbd302b95}}

The catMaybes function takes an \passthrough{\lstinline!Iterable!} of
\passthrough{\lstinline!MaybeType!}s and returns a
\passthrough{\lstinline!SequenceType!} of all the Just's values.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} &
\passthrough{\lstinline!Iterable<MaybeType<\_T\_>>!} & The receiver of
this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=c921a7df-d43a-415d-a1b5-9889435c00cf]
const maybes = [Just(5), Just(3), Nothing];
const result = catMaybes(maybes);
                                           
console.log(...result);
// => Logs '5, 3'
\end{lstlisting}

\hypertarget{ff34208c-02f2-42f6-b821-a3deb97e4b1b}{%
\subsubsection{concat}\label{ff34208c-02f2-42f6-b821-a3deb97e4b1b}}

Adds the second iterable to the first iterables end.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The receiver of this
operator. \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The
\passthrough{\lstinline!Iterable!} to concat. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=18038071-1b77-4cab-aa88-5e597bf2423d]
const numbers = [0, 1, 2];
const range   = Range(2);
const concatenated = concat(numbers)(range);
                                            
console.log(...concatenated);
// => Logs '0, 1, 0, 1, 2'
\end{lstlisting}

\hypertarget{6a9773d8-0837-456a-bbbb-9c926d98a336}{%
\subsubsection{cons}\label{6a9773d8-0837-456a-bbbb-9c926d98a336}}

Adds the given element to the front of an iterable.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!element!} & \passthrough{\lstinline!\_T\_!} &
The value to put in front. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=875d77cc-924c-4f79-b69a-316c95a944d4]
const numbers  = [1, 2, 3];
const element  = 0;
const consed = cons(element)(numbers);
                                      
console.log(...consed);
// => Logs '0, 1, 2, 3, 4'
\end{lstlisting}

\hypertarget{9e681fc2-fb6e-4844-853e-d8238b44a848}{%
\subsubsection{cycle}\label{9e681fc2-fb6e-4844-853e-d8238b44a848}}

Ties a finite \passthrough{\lstinline!Iterable!} into a circular one, or
equivalently, the infinite repetition of the original
\passthrough{\lstinline!Iterable!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=95f0febe-03e7-4da3-91b7-135c75ca4b96]
const numbers = [0, 1, 2];
const cycled = cycle(numbers);
const result = take(6)(cycled);
                               
console.log(...result);
// => Logs '0, 1, 2, 0, 1, 2'
\end{lstlisting}

\hypertarget{35daaeb3-b3ac-47ea-818b-89d3786249a2}{%
\subsubsection{drop}\label{35daaeb3-b3ac-47ea-818b-89d3786249a2}}

Jumps over so many elements.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} & \passthrough{\lstinline!Number!} & The
amount ofelements to drop \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=30264928-f65c-4618-9003-3370ee05bb51]
const numbers = [0, 1, 2, 3];
const dropped = drop(2)(numbers);
                                 
console.log(...dropped);
// => Logs '2, 3'
\end{lstlisting}

\hypertarget{66ea1665-a0b4-4fa6-887f-aeb9507f83b2}{%
\subsubsection{dropWhile}\label{66ea1665-a0b4-4fa6-887f-aeb9507f83b2}}

Discards all elements until the first element does not satisfy the
predicate anymore.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & Drops elements fulfilling
this predicate. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=6eda0eb3-c4be-4257-85f9-929d969986a0]
const numbers = [0, 1, 2, 3, 4, 5];
const dropped = dropWhile(el => el < 2)(numbers);
                                                 
console.log(...dropped);
// Logs '2, 3, 4, 5'
\end{lstlisting}

\hypertarget{c353a5b1-74a9-4860-8859-5cb1db0001ed}{%
\subsubsection{map}\label{c353a5b1-74a9-4860-8859-5cb1db0001ed}}

Transforms each element using the given \{@link Functor function\}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!mapper!} &
\passthrough{\lstinline!Functor<\_U\_, \_T\_>!} & Is applied on each
element. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=84de7cd1-052e-4191-b5df-e13e9aa8c128]
const numbers = [0, 1, 2];
const mapped  = map(el => el * 2)(numbers);
                                           
console.log(...numbers);
// => Logs '0, 2, 4'
\end{lstlisting}

\hypertarget{3dce9274-3bb4-45df-95d1-5e63e59c508b}{%
\subsubsection{mconcat}\label{3dce9274-3bb4-45df-95d1-5e63e59c508b}}

Flatten an \passthrough{\lstinline!Iterable!} of
\passthrough{\lstinline!Iterable!}s.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} &
\passthrough{\lstinline!Iterable<Iterable<\_T\_>>!} & The receiver of
this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=4f37aea0-6d8f-468e-826f-2b141d150be7]
const ranges = map(x => Range(x))(Range(2));
const result = mconcat(ranges);
                                            
console.log(...result);
// => Logs '0, 0, 1, 0, 1, 2'
\end{lstlisting}

\hypertarget{de7946de-4204-4528-9d70-80292415d206}{%
\subsubsection{pipe}\label{de7946de-4204-4528-9d70-80292415d206}}

Transforms the given \passthrough{\lstinline!Iterable!} using the passed
operators.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_> | *!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!transformers!} &
\passthrough{\lstinline!SequenceOperation<*!}\emph{\passthrough{\lstinline!,*!}}\passthrough{\lstinline!>!}
& The operators to apply . \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=389d95f0-7103-4244-a572-b4a0457aa4ae]
const piped = pipe(
               retainAll(n => n % 2 === 0),
               map(n => 2*n),
               drop(2)
             )([0,1,2,3,4,5]);
                                           
console.log(...piped);
// => Logs '0, 4, 8'
\end{lstlisting}

\hypertarget{fa673517-e861-4391-b582-0decb366cb72}{%
\subsubsection{rejectAll}\label{fa673517-e861-4391-b582-0decb366cb72}}

Only keeps elements which does not fulfill the given predicate.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & Ignores elements fulfilling
this predicate. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=a0a61f28-ccde-43a7-b440-9cfb64243aaf]
const filtered = rejectAll(el => el % 2 === 0)([0, 1, 2, 3, 4, 5]);

console.log(...filtered);
// => Logs '1, 3, 5'
\end{lstlisting}

\hypertarget{cfd0f69c-c3d5-4e1b-90f6-c7f1dd9d258e}{%
\subsubsection{retainAll}\label{cfd0f69c-c3d5-4e1b-90f6-c7f1dd9d258e}}

Only keeps elements which fulfill the given predicate.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & Keeps elements fulfilling
this predicate. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=8a34b1cf-0a5d-4f78-876d-3d2977eb069b]
const filtered = retainAll(el => el % 2 === 0)([0, 1, 2, 3, 4, 5]);

console.log(...filtered);
// => Logs '0, 2, 4'
\end{lstlisting}

\hypertarget{cfab75a9-3295-4c45-be64-d5e9dc24f024}{%
\subsubsection{reverse\$}\label{cfab75a9-3295-4c45-be64-d5e9dc24f024}}

Processes the \passthrough{\lstinline!Iterable!} backwards.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=166e8d11-881b-4158-8801-cc8314501b92]
const reversed = reverse$([0, 1, 2]);
                                   
console.log(...reversed);
// => Logs '2, 1, 0'
\end{lstlisting}

\hypertarget{2a8b7db1-3dc9-494e-9b73-5921e8508471}{%
\subsubsection{snoc}\label{2a8b7db1-3dc9-494e-9b73-5921e8508471}}

Adds the given element to the end of the
\passthrough{\lstinline!Iterable!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!element!} & \passthrough{\lstinline!\_T\_!} &
The element to add. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=eca2c8ba-39bb-4044-81c8-996f42643934]
const snocced = snoc(7)([0, 1, 2, 3]);
                                      
console.log(...snocced);
// => Logs '0, 1, 2, 3, 7'
\end{lstlisting}

\hypertarget{78987131-f1a4-443e-89de-8a3d68ccbdbf}{%
\subsubsection{take}\label{78987131-f1a4-443e-89de-8a3d68ccbdbf}}

Stop after so many elements.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} & \passthrough{\lstinline!Number!} & The
amount of elements to keep \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=e8ce9038-50f4-4af9-b2fb-5de4fd45e2ca]
const taken   = take(2)([0,1,2,3]);
                                   
console.log(...taken);
// => Logs '0, 1'
\end{lstlisting}

\hypertarget{00fcf74e-3b9e-4957-bbe5-f4ffcb3b6ae5}{%
\subsubsection{takeWhile}\label{00fcf74e-3b9e-4957-bbe5-f4ffcb3b6ae5}}

Proceeds with the iteration until the predicate becomes true.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & keeps elements until this
predicate fails. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=643a92b4-09d7-4bc6-aa4b-dab46314eaa3]
const dropped = takeWhile(el => el <= 2)([0, 1, 2, 3, 4 ,5]);
                                                               
console.log(...result);
// => Logs '0, 1, 2'
\end{lstlisting}

\hypertarget{9bca8d6e-83f7-4964-87ac-3f1be94d150d}{%
\subsubsection{zip}\label{9bca8d6e-83f7-4964-87ac-3f1be94d150d}}

Zip takes two \passthrough{\lstinline!Iterable!}s and returns an
\passthrough{\lstinline!Iterable!} of corresponding
\passthrough{\lstinline!Pair!}s.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The receiver of this
operator. \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_U\_>!} & The second
\passthrough{\lstinline!Iterable!} \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=960fcdca-f1f5-465e-a398-6966c47e3f02]
const numbers = [0, 1, 2],
const range   = Range(3, 5);
const zipped  = zip(numbers)(range);
                                         
forEach$(x => console.log(...x))(zipped);
// => Logs '0 3, 1 4, 2 5'
\end{lstlisting}

\hypertarget{1a453b49-15f0-4893-ac16-295a516efc66}{%
\subsubsection{zipWith}\label{1a453b49-15f0-4893-ac16-295a516efc66}}

Generalises zip by zipping with the function given as the first
argument.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!zipper!} &
\passthrough{\lstinline!BiFunction<\_T\_, \_U\_, \_V\_>!} & The function
to combine two elements. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bcceae38-355f-4d33-9233-3c55fcda81d9]
const numbers = [0, 1, 2];
const range   = Range(2, 4);
const zipped  = zipWith((i,j) => [i,j])(numbers)(range);
console.log(...zipped);
                                                        
// => Logs '[0,2], [1,3], [2,4]'
\end{lstlisting}

\hypertarget{fe5771c4-997c-4878-97c6-42d757c1418a}{%
\subsection{Terminal Operations}\label{sub:appendix_terminal_operations}}

All the following operations transform an
\passthrough{\lstinline!Iterable!} into a single value.

\hypertarget{bd20be56-f445-48bf-bdf2-a716e1236a4d}{%
\subsubsection{eq\$}\label{bd20be56-f445-48bf-bdf2-a716e1236a4d}}

Checks the equality of two
non-infinite\passthrough{\lstinline!Iterable!}s.

\emph{Note:} Two iterables are considered as equal if they contain or
create the exactly same values in the same order. Use
\passthrough{\lstinline!["=="]!} defined on the SequencePrototype to
perform a comparison in a more readable form.

\textbf{Returns}: \passthrough{\lstinline!Boolean!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The first
\passthrough{\lstinline!Iterable!} \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The receiver of this
operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b46ef356-2dcb-4c5a-b345-f74828804c55]
const numbers = [0, 1, 2, 3];
const range   = Range(3);
const result  = eq$(numbers)(range);
                                    
console.log(result);
// => Logs 'true'
\end{lstlisting}

\hypertarget{ef923738-324f-424a-8151-1706b42a416d}{%
\subsubsection{foldr}\label{ef923738-324f-424a-8151-1706b42a416d}}

Performs a reduction on the elements from right to left, using the
provided start value and an accumulation function, and returns the
reduced value.

Since \passthrough{\lstinline!foldr!} reduces the
\passthrough{\lstinline!Iterable!} from right to left, it needs O(n)
memory to run the function. Therefore \passthrough{\lstinline!reduce$!}
is the better alternative for most cases

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!accumulationFn!} &
\passthrough{\lstinline!BiFunction<\_U\_, \_T\_, \_T\_>!} & the
reduction function \\
\passthrough{\lstinline!start!} & \passthrough{\lstinline!\_T\_!} & The
first value \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=899c82bd-0132-4f44-bf93-a84abb761f92]
const numbers = [0, 1, 2, 3, 4, 5];
const result  = foldr$((cur, acc) => cur + acc, 0)(numbers);
                                                            
console.log(result);
// => Logs '15'
\end{lstlisting}

\hypertarget{ae20de4d-81d9-49b3-a519-ce7fcad4bf13}{%
\subsubsection{forEach\$}\label{ae20de4d-81d9-49b3-a519-ce7fcad4bf13}}

Executes the callback for each element.

\textbf{Returns}: \passthrough{\lstinline!void!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!callback!} &
\passthrough{\lstinline!Consumer<\_T\_>!} & The callback to execute for
each element. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b489cddb-c6bb-4f87-9424-e1eca34f483b]
const container = [];
forEach$(cur => container.push(cur))([0, 1, 2, 3, 4];);
                                              
console.log(...container);
// => Logs '0, 1, 2, 3, 4'
\end{lstlisting}

\hypertarget{63acb1d6-3cf2-483f-9d14-aff83ac9fa7b}{%
\subsubsection{head}\label{63acb1d6-3cf2-483f-9d14-aff83ac9fa7b}}

Return the next value without consuming it.
\passthrough{\lstinline!undefined!} when there is no value.

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=52bff184-a4bc-4651-9a65-eace96baeaa5]
const numbers = [1, 2, 3, 4];
const result  = head(numbers);
                              
console.log(result);
// => Logs '1'
\end{lstlisting}

\hypertarget{4f9c8f02-8045-4c55-980b-19761e4a0c5c}{%
\subsubsection{isEmpty}\label{4f9c8f02-8045-4c55-980b-19761e4a0c5c}}

Returns true, if the iterables head is undefined.

\textbf{Returns}: \passthrough{\lstinline!Boolean!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=636c2abf-60c6-4c38-a240-b51fa06f74b1]
const empty     = []
const result = isEmpty(empty);
                              
console.log(result);
// Logs 'true'
\end{lstlisting}

\hypertarget{f5d04902-359f-4b27-b811-851551c0d1fe}{%
\subsubsection{max\$}\label{f5d04902-359f-4b27-b811-851551c0d1fe}}

Returns the largest element of a \textbf{non-empty}
\passthrough{\lstinline!Iterable!}.

Note:

To determine the largest element, a comparator function is used. This
function compares two elements by default with the
\passthrough{\lstinline!< (LT)!} operator, where on the left side is the
current largest element when processing the iterable. If needed, a
different comparator can also be passed as a second argument to
\passthrough{\lstinline!max$!} and will then be used to determine the
largest element.

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{throws}: \passthrough{\lstinline!Error!}, if the given
\passthrough{\lstinline!Iterable!} is empty

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & An optional
comparing function which returns true if the second argument is larger
than the first. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=88fe2a41-ef34-4624-a8a7-c7571e410912]
const numbers = [1, 3, 0, 5];
const maximum = max$(numbers);
                              
console.log(maximum);
// => Logs '5'
\end{lstlisting}

\hypertarget{acc84b7e-1143-48cb-888d-767e0d324309}{%
\subsubsection{safeMax\$}\label{acc84b7e-1143-48cb-888d-767e0d324309}}

Returns the largest element of an \passthrough{\lstinline!Iterable!}.

See the Note to \passthrough{\lstinline!max$!}.

\textbf{Returns}: \passthrough{\lstinline!MaybeType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & An optional
comparing function which returns true if the second argument is larger
than the first. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7b86eb50-6997-4099-a79d-0a699d114077]
const numbers = [1, 3, 0, 5];
const maybeMax = safeMax$(numbers);
                                                 
maybeMax
 (_ => console.log("iterable was empty, no max!")
 (x => console.log(x));
// => Logs '5'
\end{lstlisting}

\hypertarget{4262f292-d5a6-4e34-acfa-e4a74506c1c1}{%
\subsubsection{min\$}\label{4262f292-d5a6-4e34-acfa-e4a74506c1c1}}

Returns the smallest element of a \textbf{non-empty} \{@link Iterable\}.

See the Note to \passthrough{\lstinline!max$!}.

\textbf{throws}: \passthrough{\lstinline!Error!}, if the given
\passthrough{\lstinline!Iterable!} is empty

\textbf{Returns}:
MaybeType\textless{}\passthrough{\lstinline!\_T\_!}\textgreater{}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & An optional
comparing function which returns true if the first argument is smaller
than the second. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=572f6b0e-eb5f-40d5-b97e-e94634aa3d6b]
const numbers = [1, 3, 0, 5];
const minimum = min$(numbers);
                              
console.log(minimum);
// => Logs '0'
\end{lstlisting}

\hypertarget{22fcb726-cee7-4692-9189-a7f90875accc}{%
\subsubsection{safeMin\$}\label{22fcb726-cee7-4692-9189-a7f90875accc}}

Returns the smallest element of an \passthrough{\lstinline!Iterable!}.

\textbf{Returns}: \passthrough{\lstinline!MaybeType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & An optional
comparing function which returns true if the first argument is smaller
than the second. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=fa712c67-7a58-4fdf-a963-b5c88f702251]
const numbers  = [0, 1, 2, 3];
const maybeMin = safeMin$(numbers);
                                                 
maybeMin
 (_ => console.log("iterable was empty, no min!")
 (x => console.log(x));
// => Logs '0'
\end{lstlisting}

\hypertarget{8e9a31f3-adef-4efe-b6bd-884d685ebc44}{%
\subsubsection{foldl\$}\label{8e9a31f3-adef-4efe-b6bd-884d685ebc44}}

Performs a reduction on the elements, using the provided start value and
an accumulation function, and returns the reduced value.

\passthrough{\lstinline!foldl$!} is an alias for
\passthrough{\lstinline!reduce$!}

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!accumulationFn!} &
\passthrough{\lstinline!BiFunction<\_T\_, \_U\_, \_T\_>!} & the
reduction function \\
\passthrough{\lstinline!start!} & \passthrough{\lstinline!\_T\_!} & The
first value \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bb223e1b-3689-41f0-8cd6-ff38d5b3a40b]
const number = [0, 1, 2, 3, 4, 5];
const res = foldl$((acc, cur) => acc + cur, 0)(numbers);
                                                        
console.log(res);
// => logs '15'
\end{lstlisting}

\hypertarget{6a4d6129-8352-449e-84de-cb0b60fbf845}{%
\subsubsection{show}\label{6a4d6129-8352-449e-84de-cb0b60fbf845}}

Transforms the passed \passthrough{\lstinline!Iterable!} to a
\passthrough{\lstinline!String!}.

\textbf{Returns}: \passthrough{\lstinline!String!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!maxValues!} & \passthrough{\lstinline!Number!} &
optional: The amount of elements that should be printed at most \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7e589eab-b8b6-4efa-8f88-a1f246754972]
const numbers = [0, 1, 2, 3, 4, 5];
const text    = show(numbers, 3);
                                   
console.log(text);
// Logs '[0,1,2]'
\end{lstlisting}

\hypertarget{235974db-05c7-4513-8478-7d9ca31e50b4}{%
\subsubsection{uncons}\label{235974db-05c7-4513-8478-7d9ca31e50b4}}

Removes the first element of this iterable.

\textbf{Returns}:
\passthrough{\lstinline!Pair<\_T\_, SequenceType<\_T\_>!} the head and
the tail as a pair

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!iterable!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The receiver of this
operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7a7b4acd-51a2-4d02-ba76-76bc89af2bfc]
const numbers       = [0, 1, 2, 3, 4];
const [head, tail]  = uncons(numbers);
                                             
console.log("head:", head, "tail:", ...tail);
// => Logs 'head: 0 tail: 1 2 3 4'
\end{lstlisting}

