% irgendwo
\newcommand{\passthrough}[1]{#1}

\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\hypertarget{api}{%
\chapter{API}\label{api}}

\hypertarget{fa229d10-532a-4f04-9805-8fdc4881587a}{%
\section{Constructors}\label{fa229d10-532a-4f04-9805-8fdc4881587a}}

All functions listed below create new sequences from non-sequence
values. They are therefore called constructors.

\hypertarget{eb038883-6cbc-4daf-ad04-f8c2e25f9a33}{%
\subsubsection{nil}\label{eb038883-6cbc-4daf-ad04-f8c2e25f9a33}}

This constant represents a sequence containing no values.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<*>!}

\textbf{Example}

\begin{lstlisting}[label=5c45c9fa-4663-4eae-8965-8bea240591b4]
const emptySequence = nil;
                              
console.log(...emptySequence);
// => Logs '' (nothing)
\end{lstlisting}

\hypertarget{c35d49b1-5a40-4fb7-b9cd-225357873654}{%
\subsubsection{PureSequence}\label{c35d49b1-5a40-4fb7-b9cd-225357873654}}

Creates a sequence which contains just the given value.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!value!} & \passthrough{\lstinline!\_T\_!} & the
single value \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=2effd3f2-45c8-4259-a1bd-334cff141bed]
const seq = PureSequence(1);
                            
console.log(...seq);
// => Logs '1'
\end{lstlisting}

\hypertarget{e7e1ec85-cbd1-4fcc-82b6-64656687aa6d}{%
\subsubsection{Range}\label{e7e1ec85-cbd1-4fcc-82b6-64656687aa6d}}

Creates a range of numbers between two inclusive boundaries, that
implements the JS iteration protocols. First and second boundaries can
be specified in arbitrary order, step size is always the third
parameter.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!firstBoundary!} &
\passthrough{\lstinline!Number!} & the first boundary of the range \\
\passthrough{\lstinline!secondBoundary!} &
\passthrough{\lstinline!Number!} & optionally the second boundary of the
range \\
\passthrough{\lstinline!step!} & \passthrough{\lstinline!Number!} & the
size of a step, processed during each iteration \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=a80a2826-2fd4-4453-9a72-3115be56483c]
const range               = Range(3);
const [five, three, one]  = Range(1, 5, -2);
const [three, four, five] = Range(5, 3);
                                            
console.log(...range);
// => Logs '0, 1, 2, 3'
\end{lstlisting}

\hypertarget{b8320e90-38a3-4df2-9770-a69376449fe3}{%
\subsubsection{repeat}\label{b8320e90-38a3-4df2-9770-a69376449fe3}}

Returns a Sequence that will repeatedly yield the value of
\passthrough{\lstinline!arg!} when iterated over.
\passthrough{\lstinline!repeat!} will never be exhausted.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!arg!} & \passthrough{\lstinline!\_T\_!} & the
value to repeat \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bd4ef248-0e38-4975-9d86-0bd39d562690]
const ones   = repeat(1);
const result = take(3)(ones);
                             
console.log(...result);
// => Logs '1, 1, 1'
\end{lstlisting}

\hypertarget{deb72945-4996-448f-a8dc-5256934ab44c}{%
\subsubsection{replicate}\label{deb72945-4996-448f-a8dc-5256934ab44c}}

\passthrough{\lstinline!replicate(n)(x)!} creates a Sequence of length
\passthrough{\lstinline!n!} with \passthrough{\lstinline!x!} the value
of every element.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!n!} & \passthrough{\lstinline!Number!} & how
many times the valued should be repeated \\
\passthrough{\lstinline!x!} & \passthrough{\lstinline!\_T\_!} & the
value to repeat \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=ccbcf172-af5e-478c-8044-fbe706545e55]
const trues = replicate(3)(true);
                                 
console.log(...trues);
// => Logs 'true, true, true'
\end{lstlisting}

\hypertarget{b80b5d30-4053-4091-842b-ddc5e8cb7195}{%
\subsubsection{Sequence}\label{b80b5d30-4053-4091-842b-ddc5e8cb7195}}

The \passthrough{\lstinline!incrementFunction!} should change the value
(make progress) in a way that the \passthrough{\lstinline!ntilFunction!}
function can recognize the end of the sequence.

Contract:

\begin{itemize}
\tightlist
\item
  \passthrough{\lstinline!incrementFunction!} \&
  \passthrough{\lstinline!untilFunction!} should not refer to any
  mutable state variable (because of side effect) in the closure.
\end{itemize}

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!start!} & \passthrough{\lstinline!Number!} & the
first value to be returned by this sequence \\
\passthrough{\lstinline!whileFunction!} &
\passthrough{\lstinline!(\_T\_) => Boolean!} & returns false if the
iteration should stop \\
\passthrough{\lstinline!incrementFunction!} &
\passthrough{\lstinline!(\_T\_) => T!} & calculates the next value based
on the previous \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=5406966c-7de8-40e2-a7bc-d4b4bf19446e]
const start      = 0;
const untilF     = x => x < 3;
const incrementF = x => x + 1;
const sequence   = Sequence(start, untilF, incrementF);
                                                       
console.log(...sequence);
// => Logs '0, 1, 2'
\end{lstlisting}

\hypertarget{d2f69237-b438-43d6-ba25-b401cd07e451}{%
\subsubsection{StackSequence}\label{d2f69237-b438-43d6-ba25-b401cd07e451}}

Creates a \passthrough{\lstinline!SequenceType!} on top of the given
\passthrough{\lstinline!stack!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!stack!} & \passthrough{\lstinline!stack!} & each
iteration returns the next element of this stack \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=4970f526-c453-4fad-a16a-c8a8cf65dbfd]
const stack         = push(push(push(emptyStack)(1))(2))(3);
const stackSequence = StackSequence(stack);
                                                            
console.log(...stackSequence);
// => Logs: '3, 2, 1'
\end{lstlisting}

\hypertarget{fcc27098-0cc2-44bc-98e9-51b45c2612d4}{%
\subsubsection{TupleSequence}\label{fcc27098-0cc2-44bc-98e9-51b45c2612d4}}

Constructs a new sequence based on the given tuple.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.2}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.466666}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
  
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} &
\passthrough{\lstinline!(f:ArrayApplierType<\_T\_>) => any!} & each
iteration returns an element of the tuple \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=d339d35f-afff-4109-a8f7-348b7f8d90b4]
const [Triple]      = Tuple(3);
const triple        = Triple(1)(2)(3);
const tupleSequence = TupleSequence(triple);
                                            
console.log(...tupleSequence);
// => Logs '1, 2, 3'
\end{lstlisting}

\hypertarget{569b08a0-06b3-45e3-b4e9-576f534c5301}{%
\section{Operators}\label{569b08a0-06b3-45e3-b4e9-576f534c5301}}

All of the following functions operate on sequences and iterables. They
all return a new sequence.

\hypertarget{ac6d2b03-9c43-4e0e-8308-92102a526003}{%
\subsubsection{bind}\label{ac6d2b03-9c43-4e0e-8308-92102a526003}}

Applies the given function to each element of the
\passthrough{\lstinline!Iterable!} and flattens it afterward. Note: This
operation adds a monadic API to the
\passthrough{\lstinline!SequenceType!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.56666666}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!bindFn!} &
\passthrough{\lstinline!<\_U\_>(bindFn: (\_T\_) => Iterable<\_U\_>)!} &
this function will be applied to each element of the iterable \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=88beac1a-9eb8-42b2-b315-c2e69ef8bdbf]
const numbers = [0, 1, 2, 3];
const bindFn  = el => take(el)(repeat(el));
const result  = bind(bindFn)(numbers);
                                           
console.log(...result);
// => Logs '1, 2, 2, 3, 3, 3'
\end{lstlisting}

\hypertarget{341a8910-fef6-491a-ad04-e13dbd302b95}{%
\subsubsection{catMaybes}\label{341a8910-fef6-491a-ad04-e13dbd302b95}}

The catMaybes function takes an iterable of maybes and returns a
sequence of all the Just's values.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
  
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} &
\passthrough{\lstinline!Iterable<MaybeType<\_T\_>>!} & the receiver of
this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=c921a7df-d43a-415d-a1b5-9889435c00cf]
const maybes = [Just(5), Just(3), Nothing];
const result = catMaybes(maybes);
                                           
console.log(...result);
// => Logs '5, 3'
\end{lstlisting}

\hypertarget{ff34208c-02f2-42f6-b821-a3deb97e4b1b}{%
\subsubsection{concat}\label{ff34208c-02f2-42f6-b821-a3deb97e4b1b}}

Adds the second iterable to the first iterables end.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
  
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the receiver of this
operator \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the iterable to concat \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=18038071-1b77-4cab-aa88-5e597bf2423d]
const numbers = [0, 1, 2];
const range   = Range(2);
const concatenated = concat(numbers)(range);
                                            
console.log(...concatenated);
// => Logs '0, 1, 0, 1, 2'
\end{lstlisting}

\hypertarget{6a9773d8-0837-456a-bbbb-9c926d98a336}{%
\subsubsection{cons}\label{6a9773d8-0837-456a-bbbb-9c926d98a336}}

Adds the given element to the front of an iterable.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}
  
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!element!} & \passthrough{\lstinline!\_T\_!} &
the value to put in front \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=875d77cc-924c-4f79-b69a-316c95a944d4]
const numbers  = [1, 2, 3];
const element  = 0;
const consed = cons(element)(numbers);
                                      
console.log(...consed);
// => Logs '0, 1, 2, 3, 4'
\end{lstlisting}

\hypertarget{9e681fc2-fb6e-4844-853e-d8238b44a848}{%
\subsubsection{cycle}\label{9e681fc2-fb6e-4844-853e-d8238b44a848}}

Ties a finite iterable into a circular one, or equivalently, the
infinite repetition of the original iterable.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=95f0febe-03e7-4da3-91b7-135c75ca4b96]
const numbers = [0, 1, 2];
const cycled = cycle(numbers);
const result = take(6)(cycled);
                               
console.log(...result);
// => Logs '0, 1, 2, 0, 1, 2'
\end{lstlisting}

\hypertarget{35daaeb3-b3ac-47ea-818b-89d3786249a2}{%
\subsubsection{drop}\label{35daaeb3-b3ac-47ea-818b-89d3786249a2}}

Jumps over so many elements.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} & \passthrough{\lstinline!Number!} & the
amount of elements to drop \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=30264928-f65c-4618-9003-3370ee05bb51]
const numbers = [0, 1, 2, 3];
const dropped = drop(2)(numbers);
                                 
console.log(...dropped);
// => Logs '2, 3'
\end{lstlisting}

\hypertarget{66ea1665-a0b4-4fa6-887f-aeb9507f83b2}{%
\subsubsection{dropWhile}\label{66ea1665-a0b4-4fa6-887f-aeb9507f83b2}}

Discards all elements until the first element does not satisfy the
predicate anymore.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & drops elements fulfilling
this predicate \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=6eda0eb3-c4be-4257-85f9-929d969986a0]
const numbers = [0, 1, 2, 3, 4, 5];
const dropped = dropWhile(el => el < 2)(numbers);
                                                 
console.log(...dropped);
// => Logs '2, 3, 4, 5'
\end{lstlisting}

\hypertarget{c353a5b1-74a9-4860-8859-5cb1db0001ed}{%
\subsubsection{map}\label{c353a5b1-74a9-4860-8859-5cb1db0001ed}}

Transforms each element using the given function.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!mapper!} &
\passthrough{\lstinline!Functor<\_U\_, \_T\_>!} & is applied on each
element \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=84de7cd1-052e-4191-b5df-e13e9aa8c128]
const numbers = [0, 1, 2];
const mapped  = map(el => el * 2)(numbers);
                                           
console.log(...numbers);
// => Logs '0, 2, 4'
\end{lstlisting}

\hypertarget{3dce9274-3bb4-45df-95d1-5e63e59c508b}{%
\subsubsection{mconcat}\label{3dce9274-3bb4-45df-95d1-5e63e59c508b}}

Flatten an iterable of iterables.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} &
\passthrough{\lstinline!Iterable<Iterable<\_T\_>>!} & the receiver of
this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=4f37aea0-6d8f-468e-826f-2b141d150be7]
const ranges = map(x => Range(x))(Range(2));
const result = mconcat(ranges);
                                            
console.log(...result);
// => Logs '0, 0, 1, 0, 1, 2'
\end{lstlisting}

\hypertarget{de7946de-4204-4528-9d70-80292415d206}{%
\subsubsection{pipe}\label{de7946de-4204-4528-9d70-80292415d206}}

Transforms the given iterable using the passed operators.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_> | *!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!transformers!} &
\passthrough{\lstinline!SequenceOperation<*!}\emph{\passthrough{\lstinline!,*!}}\passthrough{\lstinline!>!}
& the operators to apply \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=389d95f0-7103-4244-a572-b4a0457aa4ae]
const piped = pipe(
               retainAll(n => n % 2 === 0),
               map(n => 2*n),
               drop(2)
             )([0,1,2,3,4,5]);
                                           
console.log(...piped);
// => Logs '0, 4, 8'
\end{lstlisting}

\hypertarget{fa673517-e861-4391-b582-0decb366cb72}{%
\subsubsection{rejectAll}\label{fa673517-e861-4391-b582-0decb366cb72}}

Only keeps elements which do not fulfil the given predicate.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & ignores elements fulfilling
this predicate \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=a0a61f28-ccde-43a7-b440-9cfb64243aaf]
const filtered = rejectAll(el => el % 2 === 0)([0, 1, 2, 3, 4, 5]);

console.log(...filtered);
// => Logs '1, 3, 5'
\end{lstlisting}

\hypertarget{cfd0f69c-c3d5-4e1b-90f6-c7f1dd9d258e}{%
\subsubsection{retainAll}\label{cfd0f69c-c3d5-4e1b-90f6-c7f1dd9d258e}}

Only keeps elements which fulfil the given predicate.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & keeps elements fulfilling
this predicate \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=8a34b1cf-0a5d-4f78-876d-3d2977eb069b]
const filtered = retainAll(el => el % 2 === 0)([0, 1, 2, 3, 4, 5]);

console.log(...filtered);
// => Logs '0, 2, 4'
\end{lstlisting}

\hypertarget{cfab75a9-3295-4c45-be64-d5e9dc24f024}{%
\subsubsection{reverse\$}\label{cfab75a9-3295-4c45-be64-d5e9dc24f024}}

Processes the iterable backwards.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=166e8d11-881b-4158-8801-cc8314501b92]
const reversed = reverse$([0, 1, 2]);
                                   
console.log(...reversed);
// => Logs '2, 1, 0'
\end{lstlisting}

\hypertarget{2a8b7db1-3dc9-494e-9b73-5921e8508471}{%
\subsubsection{snoc}\label{2a8b7db1-3dc9-494e-9b73-5921e8508471}}

Adds the given element to the end of the iterable. It is the opposite of
\passthrough{\lstinline!cons!}

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!element!} & \passthrough{\lstinline!\_T\_!} &
the element to add \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=eca2c8ba-39bb-4044-81c8-996f42643934]
const snocced = snoc(7)([0, 1, 2, 3]);
                                      
console.log(...snocced);
// => Logs '0, 1, 2, 3, 7'
\end{lstlisting}

\hypertarget{78987131-f1a4-443e-89de-8a3d68ccbdbf}{%
\subsubsection{take}\label{78987131-f1a4-443e-89de-8a3d68ccbdbf}}

Stop after so many elements.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!count!} & \passthrough{\lstinline!Number!} & he
amount of elements to keep \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=e8ce9038-50f4-4af9-b2fb-5de4fd45e2ca]
const taken   = take(2)([0,1,2,3]);
                                   
console.log(...taken);
// => Logs '0, 1'
\end{lstlisting}

\hypertarget{00fcf74e-3b9e-4957-bbe5-f4ffcb3b6ae5}{%
\subsubsection{takeWhile}\label{00fcf74e-3b9e-4957-bbe5-f4ffcb3b6ae5}}

Proceeds with the iteration until the predicate becomes true.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!predicate!} &
\passthrough{\lstinline!Predicate<\_T\_>!} & keeps elements until this
predicate fails \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operator \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=643a92b4-09d7-4bc6-aa4b-dab46314eaa3]
const dropped = takeWhile(el => el <= 2)([0, 1, 2, 3, 4 ,5]);
                                                               
console.log(...result);
// => Logs '0, 1, 2'
\end{lstlisting}

\hypertarget{9bca8d6e-83f7-4964-87ac-3f1be94d150d}{%
\subsubsection{zip}\label{9bca8d6e-83f7-4964-87ac-3f1be94d150d}}

Zip takes two iterables and returns an iterable of corresponding pairs.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the receiver of this
operator \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_U\_>!} & zthe second iterable \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=960fcdca-f1f5-465e-a398-6966c47e3f02]
const numbers = [0, 1, 2],
const range   = Range(3, 5);
const zipped  = zip(numbers)(range);
                                         
forEach$(x => console.log(...x))(zipped);
// => Logs '0 3, 1 4, 2 5'
\end{lstlisting}

\hypertarget{1a453b49-15f0-4893-ac16-295a516efc66}{%
\subsubsection{zipWith}\label{1a453b49-15f0-4893-ac16-295a516efc66}}

Generalises zip by zipping with the function given as the first
argument.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!zipper!} &
\passthrough{\lstinline!BiFunction<\_T\_, \_U\_, \_V\_>!} & The function
to combine two elements. \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bcceae38-355f-4d33-9233-3c55fcda81d9]
const numbers = [0, 1, 2];
const range   = Range(2, 4);
const zipped  = zipWith((i,j) => [i,j])(numbers)(range);
console.log(...zipped);
                                                        
// => Logs '[0,2], [1,3], [2,4]'
\end{lstlisting}

\hypertarget{fe5771c4-997c-4878-97c6-42d757c1418a}{%
\section{Terminal
operations}\label{fe5771c4-997c-4878-97c6-42d757c1418a}}

All of the following operations transform an iterable into a single
value.

\hypertarget{bd20be56-f445-48bf-bdf2-a716e1236a4d}{%
\subsubsection{eq\$}\label{bd20be56-f445-48bf-bdf2-a716e1236a4d}}

Checks the equality of two non-infinite iterables.

\emph{Note}: Two iterables are considered as equal if they contain or
create the exactly same values in the same order. Use
\passthrough{\lstinline!["=="]!} defined on the SequencePrototype to
perform a comparison in a more readable form.

\textbf{Returns}: \passthrough{\lstinline!Boolean!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it1!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & The first iterable \\
\passthrough{\lstinline!it2!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the receiver of this
operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b46ef356-2dcb-4c5a-b345-f74828804c55]
const numbers = [0, 1, 2, 3];
const range   = Range(3);
const result  = eq$(numbers)(range);
                                    
console.log(result);
// => Logs 'true'
\end{lstlisting}

\hypertarget{ef923738-324f-424a-8151-1706b42a416d}{%
\subsubsection{foldr}\label{ef923738-324f-424a-8151-1706b42a416d}}

Performs a reduction on the elements from right to left, using the
provided start value and an accumulation function, and returns the
reduced value.

Since \passthrough{\lstinline!foldr!} reduces the iterable from right to
left, it needs O(n) memory to run the function. Therefore
\passthrough{\lstinline!reduce$!} is the better alternative for most
cases

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!accumulationFn!} &
\passthrough{\lstinline!BiFunction<\_U\_, \_T\_, \_T\_>!} & the
reduction function \\
\passthrough{\lstinline!start!} & \passthrough{\lstinline!\_T\_!} & the
first value \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=899c82bd-0132-4f44-bf93-a84abb761f92]
const numbers = [0, 1, 2, 3, 4, 5];
const result  = foldr$((cur, acc) => cur + acc, 0)(numbers);
                                                            
console.log(result);
// => Logs '15'
\end{lstlisting}

\hypertarget{ae20de4d-81d9-49b3-a519-ce7fcad4bf13}{%
\subsubsection{forEach\$}\label{ae20de4d-81d9-49b3-a519-ce7fcad4bf13}}

Executes the callback for each element.

\textbf{Returns}: \passthrough{\lstinline!void!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!callback!} &
\passthrough{\lstinline!Consumer<\_T\_>!} & the callback to execute for
each element \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b489cddb-c6bb-4f87-9424-e1eca34f483b]
const container = [];
forEach$(cur => container.push(cur))([0, 1, 2, 3, 4];);
                                              
console.log(...container);
// => Logs '0, 1, 2, 3, 4'
\end{lstlisting}

\hypertarget{63acb1d6-3cf2-483f-9d14-aff83ac9fa7b}{%
\subsubsection{head}\label{63acb1d6-3cf2-483f-9d14-aff83ac9fa7b}}

Return the next value without consuming it.
\passthrough{\lstinline!undefined!} when there is no value.

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=52bff184-a4bc-4651-9a65-eace96baeaa5]
const numbers = [1, 2, 3, 4];
const result  = head(numbers);
                              
console.log(result);
// => Logs '1'
\end{lstlisting}

\hypertarget{4f9c8f02-8045-4c55-980b-19761e4a0c5c}{%
\subsubsection{isEmpty}\label{4f9c8f02-8045-4c55-980b-19761e4a0c5c}}

Returns \passthrough{\lstinline!true!}, if the iterables head is
undefined.

\textbf{Returns}: \passthrough{\lstinline!Boolean!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=636c2abf-60c6-4c38-a240-b51fa06f74b1]
const empty     = []
const result = isEmpty(empty);
                              
console.log(result);
// Logs 'true'
\end{lstlisting}

\hypertarget{f5d04902-359f-4b27-b811-851551c0d1fe}{%
\subsubsection{max\$}\label{f5d04902-359f-4b27-b811-851551c0d1fe}}

Returns the largest element of a \textbf{non-empty} iterable.

Note:

To determine the largest element, a comparator function is used. This
function compares two elements by default with the
\passthrough{\lstinline!< (LT)!} operator, where on the left side is the
current largest element when processing the iterable. If needed, a
different comparator can also be passed as a second argument to
\passthrough{\lstinline!max$!} and will then be used to determine the
largest element.

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{throws}: \passthrough{\lstinline!Error!}, if the given
\passthrough{\lstinline!Iterable!} is empty

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & an optional
comparing function which returns true if the second argument is larger
than the first \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=88fe2a41-ef34-4624-a8a7-c7571e410912]
const numbers = [1, 3, 0, 5];
const maximum = max$(numbers);
                              
console.log(maximum);
// => Logs '5'
\end{lstlisting}

\hypertarget{acc84b7e-1143-48cb-888d-767e0d324309}{%
\subsubsection{safeMax\$}\label{acc84b7e-1143-48cb-888d-767e0d324309}}

Returns the largest element of an iterable.

See the note to \passthrough{\lstinline!max$!}.

\textbf{Returns}: \passthrough{\lstinline!MaybeType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & an optional
comparing function which returns true if the second argument is larger
than the first \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7b86eb50-6997-4099-a79d-0a699d114077]
const numbers = [1, 3, 0, 5];
const maybeMax = safeMax$(numbers);
                                                 
maybeMax
 (_ => console.log("iterable was empty, no max!")
 (x => console.log(x));
// => Logs '5'
\end{lstlisting}

\hypertarget{4262f292-d5a6-4e34-acfa-e4a74506c1c1}{%
\subsubsection{min\$}\label{4262f292-d5a6-4e34-acfa-e4a74506c1c1}}

Returns the smallest element of a \textbf{non-empty} iterable

See the Note to \passthrough{\lstinline!max$!}.

\textbf{throws}: \passthrough{\lstinline!Error!}, if the given
\passthrough{\lstinline!Iterable!} is empty

\textbf{Returns}:
MaybeType\textless{}\passthrough{\lstinline!\_T\_!}\textgreater{}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & an optional
comparing function which returns true if the first argument is smaller
than the second \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=572f6b0e-eb5f-40d5-b97e-e94634aa3d6b]
const numbers = [1, 3, 0, 5];
const minimum = min$(numbers);
                              
console.log(minimum);
// => Logs '0'
\end{lstlisting}

\hypertarget{22fcb726-cee7-4692-9189-a7f90875accc}{%
\subsubsection{safeMin\$}\label{22fcb726-cee7-4692-9189-a7f90875accc}}

Returns the smallest element of an iterable.

See the Note to \passthrough{\lstinline!max$!}.

\textbf{Returns}: \passthrough{\lstinline!MaybeType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& The receiver of this operator. \\
\passthrough{\lstinline!comparator!} &
\passthrough{\lstinline!BiPredicate<\_T\_,\_T\_>!} & An optional
comparing function which returns true if the first argument is smaller
than the second. \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=fa712c67-7a58-4fdf-a963-b5c88f702251]
const numbers  = [0, 1, 2, 3];
const maybeMin = safeMin$(numbers);
                                                 
maybeMin
 (_ => console.log("iterable was empty, no min!")
 (x => console.log(x));
// => Logs '0'
\end{lstlisting}

\hypertarget{8e9a31f3-adef-4efe-b6bd-884d685ebc44}{%
\subsubsection{reduce\$ /
foldl\$}\label{8e9a31f3-adef-4efe-b6bd-884d685ebc44}}

Performs a reduction on the elements, using the provided start value and
an accumulation function, and returns the reduced value.

Note: \passthrough{\lstinline!foldl$!} is an alias for
\passthrough{\lstinline!reduce$!}

\textbf{Returns}: \passthrough{\lstinline!\_T\_!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!accumulationFn!} &
\passthrough{\lstinline!BiFunction<\_T\_, \_U\_, \_T\_>!} & the
reduction function \\
\passthrough{\lstinline!start!} & \passthrough{\lstinline!\_T\_!} & the
first value \\
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=bb223e1b-3689-41f0-8cd6-ff38d5b3a40b]
const number = [0, 1, 2, 3, 4, 5];
const res = foldl$((acc, cur) => acc + cur, 0)(numbers);
                                                        
console.log(res);
// => Logs '15'
\end{lstlisting}

\hypertarget{6a4d6129-8352-449e-84de-cb0b60fbf845}{%
\subsubsection{show}\label{6a4d6129-8352-449e-84de-cb0b60fbf845}}

Transforms the passed iterable into a \passthrough{\lstinline!String!}.

\textbf{Returns}: \passthrough{\lstinline!String!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!it!} & \passthrough{\lstinline!Iterable<\_T\_>!}
& the receiver of this operation \\
\passthrough{\lstinline!maxValues!} & \passthrough{\lstinline!Number!} &
optional: the amount of elements that should be printed at most \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7e589eab-b8b6-4efa-8f88-a1f246754972]
const numbers = [0, 1, 2, 3, 4, 5];
const text    = show(numbers, 3);
                                   
console.log(text);
// => Logs '[0,1,2]'
\end{lstlisting}

\hypertarget{235974db-05c7-4513-8478-7d9ca31e50b4}{%
\subsubsection{uncons}\label{235974db-05c7-4513-8478-7d9ca31e50b4}}

Removes the first element of this iterable.

\textbf{Returns}:
\passthrough{\lstinline!Pair<\_T\_, SequenceType<\_T\_>!} the head and
the tail as a pair

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!iterable!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the receiver of this
operation \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=7a7b4acd-51a2-4d02-ba76-76bc89af2bfc]
const numbers       = [0, 1, 2, 3, 4];
const [head, tail]  = uncons(numbers);
                                             
console.log("head:", head, "tail:", ...tail);
// => Logs 'head: 0 tail: 1 2 3 4'
\end{lstlisting}

\hypertarget{7ab5394b-94c8-49fd-b747-3fafa3764d32}{%
\section{The Prototype of the
Sequence}\label{7ab5394b-94c8-49fd-b747-3fafa3764d32}}

Some functions are also available via the prototype of the sequence.

\hypertarget{4e16908d-1d8b-4712-9b4c-00431a8bdb0c}{%
\subsubsection{and}\label{4e16908d-1d8b-4712-9b4c-00431a8bdb0c}}

This is the same as \passthrough{\lstinline!bind!}.

Applies the given function to each element of the sequence and flattens
it afterward. Note: This operation adds a monadic API to the
\passthrough{\lstinline!SequenceType!}.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.1}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.56666666}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!bindFn!} &
\passthrough{\lstinline!<\_U\_>(bindFn: (\_T\_) => Iterable<\_U\_>)!} &
this function will be applied to each element of the iterable \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=18e442c6-6467-4e19-bc9b-7679259b6817]
const numbers = Range(3);
const bindFn  = el => take(el)(repeat(el));
const result  = numbers.and(bindFn);
                                           
console.log(...result);
// => Logs '1, 2, 2, 3, 3, 3'
\end{lstlisting}

\hypertarget{24c00685-c1a1-48d1-9430-91d7bb8d798a}{%
\subsubsection{fmap}\label{24c00685-c1a1-48d1-9430-91d7bb8d798a}}

This is the same as \passthrough{\lstinline!map!}.

Transforms each element using the given function.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_U\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!mapper!} &
\passthrough{\lstinline!Functor<\_U\_, \_T\_>!} & is applied on each
element \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=d2a3e994-68fb-4dca-a954-00bb8432648a]
const numbers = Range(2);
const mapped  = numbers.fmap(el => el * 2);
                                           
console.log(...numbers);
// => Logs '0, 2, 4'
\end{lstlisting}

\hypertarget{3d33c9f7-0aaa-425e-8772-3ef34221985a}{%
\subsubsection{empty}\label{3d33c9f7-0aaa-425e-8772-3ef34221985a}}

This is the same as \passthrough{\lstinline!nil!}.

This functions returns a sequence containing no values.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<*>!}

\textbf{Example}

\begin{lstlisting}[label=ec0f0760-4956-481e-97d0-799b1f33e68d]
const emptySequence = Range(3).empty();
                              
console.log(...emptySequence);
// => Logs '' (nothing)
\end{lstlisting}

\hypertarget{86a0c0de-ecd3-49d6-8e0a-454e59ba0722}{%
\subsubsection{pure}\label{86a0c0de-ecd3-49d6-8e0a-454e59ba0722}}

This is the same as \passthrough{\lstinline!PureSequence!}.

Creates a sequence which contains just the given value.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_>!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!value!} & \passthrough{\lstinline!\_T\_!} & the
single value \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=b4b19961-9849-4688-8afe-9c635af8eda4]
const seq = Range(3).pure(1);
                            
console.log(...seq);
// => Logs '1'
\end{lstlisting}

\hypertarget{573dc5de-90b1-4591-8db4-da62a82d831b}{%
\subsubsection{toString}\label{573dc5de-90b1-4591-8db4-da62a82d831b}}

This is the same as \passthrough{\lstinline!show!}.

Transforms this sequence into a \passthrough{\lstinline!String!}.

\textbf{Returns}: \passthrough{\lstinline!String!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!maxValues!} & \passthrough{\lstinline!Number!} &
optional: the amount of elements that should be printed at most \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=3b9092ce-ad67-4baa-a872-a38a7455ebb4]
const numbers = Range(6);
const text    = range.toString(3);
                                   
console.log(text);
// => Logs '[0,1,2]'
\end{lstlisting}

\hypertarget{e862d602-1a86-4fc9-8159-7b7d136c9ed6}{%
\subsubsection{pipe}\label{e862d602-1a86-4fc9-8159-7b7d136c9ed6}}

This is the same as \passthrough{\lstinline!pipe!}.

Transforms this sequence using the passed operators.

\textbf{Returns}: \passthrough{\lstinline!SequenceType<\_T\_> | *!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!transformers!} &
\passthrough{\lstinline!SequenceOperation<*!}\emph{\passthrough{\lstinline!,*!}}\passthrough{\lstinline!>!}
& the operators to apply \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=30162c8f-03dd-4637-92b6-d142debe1612]
const numbers = Range(5);
const piped   = numbers.pipe(
                 retainAll(n => n % 2 === 0),
                 map(n => 2*n),
                 drop(2)
               );
                                           
console.log(...piped);
// => Logs '0, 4, 8'
\end{lstlisting}

\hypertarget{1b04f6d9-570a-4d48-9d9b-416f9e24870e}{%
\subsubsection{\texorpdfstring{\texttt{==}}{==}}\label{1b04f6d9-570a-4d48-9d9b-416f9e24870e}}

This is the same as \passthrough{\lstinline!eq$!}.

Checks the equality of this iterable with the given iterable.

\emph{Note}: Two iterables are considered as equal if they contain or
create the exactly same values in the same order. Use
\passthrough{\lstinline!["=="]!} defined on the SequencePrototype to
perform a comparison in a more readable form.

\textbf{Returns}: \passthrough{\lstinline!Boolean!}

\textbf{Parameters}

\begin{longtable}[]{
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}
  >{\raggedright\arraybackslash}p{(\columnwidth - 6\tabcolsep) * \real{0.33333333}}@{}}

\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endfirsthead
\toprule\noalign{}
Name & Type & Description \\
\midrule\noalign{}
\endhead
\bottomrule\noalign{}
\endlastfoot
\passthrough{\lstinline!that!} &
\passthrough{\lstinline!Iterable<\_T\_>!} & the other (finite) iterable
to compare with \\
\end{longtable}

\textbf{Example}

\begin{lstlisting}[label=99a9d6a3-56f6-4aba-8e0b-cfb53094b323]
const numbers = [0, 1, 2, 3];
const range   = Range(3);
const result  = range ["=="] (numbers);
                                    
console.log(result);
// => Logs 'true'
\end{lstlisting}
